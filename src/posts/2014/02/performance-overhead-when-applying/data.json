{
  "title": "Performance overhead when applying decorators to methods.",
  "content": "This is the tenth post in my series of blog posts about Python decorators and how I believe they are generally poorly implemented. It follows on from the previous post titled '[Performance overhead of using decorators](/posts/2014/02/performance-overhead-of-using-decorators/)', with the very first post in the series being '[How you implemented your Python decorator is wrong](/posts/2014/01/how-you-implemented-your-python/)'.  \n  \nIn the previous post I started looking at the performance implications of using decorators. In that post I started out by looking at the overheads when applying a decorator to a normal function, comparing a decorator implemented as a function closure to the more robust decorator implementation which has been the subject of this series of posts.  \n  \nFor a 2012 model MacBook Pro the tests yielded for a straight function call:  \n\n\n> 10000000 loops, best of 3: 0.132 usec per loop\n\nWhen using a decorator implemented as a function closure the result was:  \n\n\n> 1000000 loops, best of 3: 0.326 usec per loop\n\nAnd finally with the decorator factory described in this series of blog posts:  \n\n\n> 1000000 loops, best of 3: 0.771 usec per loop\n\nThis final figure was based on a pure Python implementation. When however the object proxy and function wrapper were implemented as a C extension, it was possible to get this down to:  \n\n\n> 1000000 loops, best of 3: 0.382 usec per loop\n\nThis result was not much different to when using a decorator implemented as a function closure.  \nWhat now for when decorators are applied to methods of a class?  \n  \n\n\n###  Overhead of having to bind functions\n\n  \n\n\nThe issue with applying decorators to methods of a class is that if you are going to honour the Python execution model, the decorator needs to be implemented as a descriptor and correctly bind methods to a class or class instance when accessed. In the decorator described in this series of posts we actually made use of that mechanism so as to be able to determine when a decorator was being applied to a normal function, instance method or class method.  \n  \nAlthough this process of binding ensures correct operation, it comes at an additional cost in overhead over what a decorator implemented as a function closure, which does not make any attempt to preserve the Python execution model, would do.  \n  \nIn order to see what extra steps occur, we can again use the Python profile hooks mechanism to trace execution of the call of our decorated function. In this case the execution of an instance method.  \nFirst lets check again what we would get for a decorator implemented as a function closure.  \n\n\n```python\n    def my_function_wrapper(wrapped):\n        def _my_function_wrapper(*args, **kwargs):\n            return wrapped(*args, **kwargs)\n        return _my_function_wrapper \n\n    class Class(object):\n        @my_function_wrapper\n        def method(self):\n            pass\n\n    instance = Class()\n\n    import sys\n\n    def tracer(frame, event, arg):\n        print(frame.f_code.co_name, event)\n\n    sys.setprofile(tracer)\n\n    instance.method()\n```\n\nThe result in running this is effectively the same as when decorating a normal function.  \n\n\n> \\_my\\_function\\_wrapper call  \n>  method call  \n>  method return  \n> \\_my\\_function\\_wrapper return\n\nWe should therefore expect that the overhead will not be substantially different when we perform actual timing tests.  \n  \nNow for when using our decorator factory. To provide context this time we need to present the complete recipe for the implementation.  \n\n\n```python\n    class object_proxy(object):\n        def __init__(self, wrapped):\n            self.wrapped = wrapped\n            try:\n                self.__name__ = wrapped.__name__\n            except AttributeError:\n                pass\n\n        @property\n        def __class__(self):\n            return self.wrapped.__class__\n\n        def __getattr__(self, name):\n            return getattr(self.wrapped, name)\n\n    class bound_function_wrapper(object_proxy):\n        def __init__(self, wrapped, instance, wrapper, binding, parent):\n            super(bound_function_wrapper, self).__init__(wrapped)\n            self.instance = instance\n            self.wrapper = wrapper\n            self.binding = binding\n            self.parent = parent\n\n        def __call__(self, *args, **kwargs):\n            if self.binding == 'function':\n                if self.instance is None:\n                    instance, args = args[0], args[1:]\n                    wrapped = functools.partial(self.wrapped, instance)\n                    return self.wrapper(wrapped, instance, args, kwargs)\n                else:\n                    return self.wrapper(self.wrapped, self.instance, args, kwargs)\n            else:\n                instance = getattr(self.wrapped, '__self__', None)\n                return self.wrapper(self.wrapped, instance, args, kwargs)\n\n        def __get__(self, instance, owner):\n            if self.instance is None and self.binding == 'function':\n                descriptor = self.parent.wrapped.__get__(instance, owner)\n                return bound_function_wrapper(descriptor, instance, self.wrapper,\n                        self.binding, self.parent)\n            return self \n\n    class function_wrapper(object_proxy):\n\n        def __init__(self, wrapped, wrapper):\n            super(function_wrapper, self).__init__(wrapped)\n            self.wrapper = wrapper\n            if isinstance(wrapped, classmethod):\n                self.binding = 'classmethod'\n            elif isinstance(wrapped, staticmethod):\n                self.binding = 'staticmethod'\n            else:\n                self.binding = 'function' \n\n        def __get__(self, instance, owner):\n            wrapped = self.wrapped.__get__(instance, owner)\n            return bound_function_wrapper(wrapped, instance, self.wrapper,\n                    self.binding, self) \n\n        def __call__(self, *args, **kwargs):\n            return self.wrapper(self.wrapped, None, args, kwargs) \n\n    def decorator(wrapper):\n        def _wrapper(wrapped, instance, args, kwargs):\n            def _execute(wrapped):\n                if instance is None:\n                    return function_wrapper(wrapped, wrapper)\n                elif inspect.isclass(instance):\n                    return function_wrapper(wrapped,\n                            wrapper.__get__(None, instance))\n                else:\n                    return function_wrapper(wrapped,\n                            wrapper.__get__(instance, type(instance)))\n            return _execute(*args, **kwargs)\n        return function_wrapper(wrapper, _wrapper)\n```\n\nWith our decorator implementation now being:  \n\n\n```python\n    @decorator\n    def my_function_wrapper(wrapped, instance, args, kwargs):\n        return wrapped(*args, **kwargs)\n```\n\nthe result we get when executing the decorated instance method of the class is:  \n\n\n```bash\n\\('\\_\\_get\\_\\_', 'call'\\) \\# function\\_wrapper  \n \\('\\_\\_init\\_\\_', 'call'\\) \\# bound\\_function\\_wrapper  \n \\('\\_\\_init\\_\\_', 'call'\\) \\# object\\_proxy  \n \\('\\_\\_init\\_\\_', 'return'\\)  \n \\('\\_\\_init\\_\\_', 'return'\\)  \n\\('\\_\\_get\\_\\_', 'return'\\)  \n \\('\\_\\_call\\_\\_', 'call'\\) \\# bound\\_function\\_wrapper  \n \\('my\\_function\\_wrapper', 'call'\\)  \n \\('method', 'call'\\)  \n \\('method', 'return'\\)  \n \\('my\\_function\\_wrapper', 'return'\\)  \n\\('\\_\\_call\\_\\_', 'return'\\)\n```\n\nAs can be seen, due to the binding of the method to the instance of the class which occurs in \\_\\_get\\_\\_\\(\\), a lot more is now happening. The overhead can therefore be expected to be significantly more also.  \n  \n\n\n###  Timing execution of the method call\n\n  \n\n\nAs before, rather than use the implementation above, the actual implementation from the wrapt library will again be used.  \nThis time our test is run as:  \n\n\n```python\n    $ python -m timeit -s 'import benchmarks; c=benchmarks.Class()' 'c.method()'\n```\n\nFor the case of no decorator being used on the instance method, the result is:  \n\n\n> 10000000 loops, best of 3: 0.143 usec per loop\n\nThis is a bit more than for the case of a normal function call due to the binding of the function to the instance which is occurring.  \n  \nNext up is using the decorator implemented as a function closure. For this we get:  \n\n\n> 1000000 loops, best of 3: 0.382 usec per loop\n\nAgain, somewhat more than the undecorated case, but not a great deal more than when the decorator implemented as a function closure was applied to a normal function. The overhead of this decorator when applied to a normal function vs a instance method is therefore not significantly different.  \n  \nNow for the case of our decorator factory and function wrapper which honours the Python execution model, by ensuring that binding of the function to the instance of the class is done correctly.  \nFirst up is where a pure Python implementation is used.  \n\n\n> 100000 loops, best of 3: 6.67 usec per loop\n\nOuch. Compared to when using a function closure to implement the decorator, this is quite an additional hit in runtime overhead.  \n  \nAlthough this is only about an extra 6 usec per call, you do need to think about this in context. In particular, if such a decorator is applied to a function which is called 1000 times in the process of handing a web request, that is an extra 6 ms added on top of the response time for that web request.  \n  \nThis is the point where many will no doubt argue that being correct is not worth it if the overhead is simply too much. But then, it also isn't likely the case that the decorated function, nor the decorator itself are going to do nothing and so the additional overhead incurred may still be a small percentage of the run time cost of those and so not in practice noticeable.  \n  \nAll the same, can the use of a C extension improve things?  \n  \nFor the case of the object proxy and function wrapper being implemented as a C extension, the result is:  \n\n\n> 1000000 loops, best of 3: 0.836 usec per loop\n\nSo instead of 6 ms, that is less than 1 ms of additional overhead if the decorated function was called a 1000 times.  \n  \nIt is still somewhat more than when using a decorator implemented as a function closure, but reiterating again, the use of a function closure when decorating a method of a class is technically broken by design as it does not honour the Python execution model.  \n  \n\n\n###  Who cares if it isn't quite correct\n\n  \nAm I splitting hairs and being overly pedantic in wanting things to be done properly?  \n  \nSure, for what you are using decorators for you may well get away with using a decorator implemented as a function closure. When you start though moving into the area of using function wrappers to perform monkey patching of arbitrary code, you cannot afford to do things in a sloppy way.  \n  \nIf you do not honour the Python execution model when doing monkey patching, you can too easily break in very subtle and obscure ways the third party code you are monkey patching. Customers don't really like it when what you do crashes their web application. So for what I need to do at least, it does matter and it matters a lot.  \n  \nNow in this post I have only considered the overhead when decorating instance methods of a class. I did not cover what the overheads are when decorating static methods and class methods. If you are curious about those and how they may be different, you can check out the benchmarks for the full range of cases in the [wrapt documentation](http://wrapt.readthedocs.org/en/latest/benchmarks.html).  \n  \nIn the next post I will touch once again on issues of performance overhead, but also a bit on alternative ways of implementing a decorator so as to try and address the problems raised in my very first post. This will be as a part of a comparison between the approach described in this series of posts and the way in which the '[decorator](https://pypi.python.org/pypi/decorator)' module available from PyPi implements its variant of a decorator factory.",
  "date": "2014-02-17",
  "author": "Graham Dumpleton",
  "url": "http://blog.dscpl.com.au/2014/02/performance-overhead-when-applying.html",
  "post_id": "4074385092944256054",
  "blog_id": "2363643920942057324",
  "comments": [
    {
      "comment_id": "618594695815465631",
      "author": "dougm",
      "author_url": "https://www.blogger.com/profile/12727771494014947867",
      "author_profile_id": "12727771494014947867",
      "content": "This is a follow-up on \"How you implemented your Python decorator is wrong.\", right? Well, I'm going to save you a lot of CPU time and code by pointing out exactly how:  \n  \n>@function\\_wrapper  \n>@classmethod  \n  \nReverse the order, and everything will work like a charm even without these AbstractSingletonMethodDecoratorFactories.  \n  \nhttp://ideone.com/Drp1cg",
      "timestamp": "February 19, 2014 at 5:14 AM",
      "permalink": "http://blog.dscpl.com.au/2014/02/performance-overhead-when-applying.html?showComment=1392747275559#c618594695815465631",
      "is_blog_author": false
    },
    {
      "comment_id": "7900535042284844903",
      "author": "Graham Dumpleton",
      "author_url": "https://www.blogger.com/profile/13609779138164842374",
      "author_profile_id": "13609779138164842374",
      "content": "Now go and write a decorator with a single implementation that can be used on both normal functions and methods of classes, and which is aware of which case it is being applied in and behave differently when it knows it is wrapping an instance method, a class method or a normal function.  \n  \nAlso come up with a generic solution for the bigger problem of monkey patching existing code to apply decorators/function wrappers, where it is not possible to change the order of the decorators because you don't have the ability to modify the original code.  \n  \nThere are use cases outside of the specific one you are thinking about where using a decorator/function wrapper implemented as a function closure simply does not work or which produces very brittle code which causes subtle run time problems.  \n  \nThere are eight other posts in this series besides this one and the very first one you referenced. These cover aspects of these other use cases, as will some future posts yet be done about the more general case of monkey patching.  \n  \nYou are taking a quite narrow view. The problem area is much bigger than you seem to think it is. So, just because you think you have a solution that works for your particular example does not mean that can be used everywhere.",
      "timestamp": "February 19, 2014 at 9:30 AM",
      "permalink": "http://blog.dscpl.com.au/2014/02/performance-overhead-when-applying.html?showComment=1392762636354#c7900535042284844903",
      "is_blog_author": true
    },
    {
      "comment_id": "6574950378433865775",
      "author": "dougm",
      "author_url": "https://www.blogger.com/profile/12727771494014947867",
      "author_profile_id": "12727771494014947867",
      "content": "Your request doesn't make sense. There's no difference between unbound methods and functions, class method and metaclass instance methods, static methods and metaclass attribute functions. If your decorator needs more than that, maybe it's a sign that you need \\*two completely different\\* decorators?  \n  \nAs for monkey patching, there's a reason it's considered bad practice. Your code is also very brittle due to replacing actual methods with descriptors.",
      "timestamp": "February 19, 2014 at 3:41 PM",
      "permalink": "http://blog.dscpl.com.au/2014/02/performance-overhead-when-applying.html?showComment=1392784901108#c6574950378433865775",
      "is_blog_author": false
    },
    {
      "comment_id": "7853392752064785699",
      "author": "Graham Dumpleton",
      "author_url": "https://www.blogger.com/profile/13609779138164842374",
      "author_profile_id": "13609779138164842374",
      "content": "Functions, methods, static methods and class methods are all what are called non-data descriptors.  \n  \nhttp://docs.python.org/2/howto/descriptor.html\\#functions-and-methods  \nhttp://docs.python.org/2/howto/descriptor.html\\#static-methods-and-class-methods  \n  \nSaying that replacing them with descriptors is somehow wrong doesn't make any sense because they are already descriptors.  \n  \nThe reason that monkey patching is generally brittle is not the practice as such, but because people don't do it properly. They simply don't understand the subtleties of how this stuff actually works under the covers. They also try and do it post import rather than at the time of import, but that is a totally different discussion.  \n  \nWhen monkey patching, if you use a descriptor to implement the wrapper and that wrapper properly implements the non-data descriptor method \\_\\_get\\_\\_\\(\\) properly and translates that into a call of \\_\\_get\\_\\_\\(\\) of the wrapped object to bind it, with any \\_\\_call\\_\\_\\(\\) then subsequently being on the bound object, then it works totally fine.  \n  \nWhere it is brittle is where people use function closures as wrappers because the function closure will not properly apply binding to the non-data descriptor which is being wrapped.  \n  \nIt only works at all in most cases because the outer wrapper passes through the self or cls as first argument anyway. Relying on that is the problem. Rely on that for a class method or static method and the result is wrong as the class method or static method never itself got to do binding and so it all breaks down.  \n  \nThis was explained in earlier posts in the series of posts. Later posts also described a concrete example of where a decorator that can be applied in different contexts, rather than having a special decorator in each case, can result in a cleaner solution which doesn't rely on hacks or the need to use multiple implementations.  \n  \nMonkey patching can be just as robust as the code which is being patched. After all, you are implementing wrappers with the same constructs that the things being wrapped used. You just need to make sure you use the correct construct and not one which bypasses the normal hidden steps that occur when calling functions, methods, static methods, class methods etc.",
      "timestamp": "February 19, 2014 at 5:22 PM",
      "permalink": "http://blog.dscpl.com.au/2014/02/performance-overhead-when-applying.html?showComment=1392790921737#c7853392752064785699",
      "is_blog_author": true
    }
  ],
  "labels": [
    "decorators",
    "python"
  ],
  "metadata": {
    "published_timestamp": "2014-02-17T23:36:00+11:00",
    "blog_title": "Graham Dumpleton",
    "page_title": "Graham Dumpleton: Performance overhead when applying decorators to methods.",
    "og_title": "Performance overhead when applying decorators to methods.",
    "og_description": "This is the tenth post in my series of blog posts about Python decorators and how I believe they are generally poorly implemented. It follow...",
    "og_url": "http://blog.dscpl.com.au/2014/02/performance-overhead-when-applying.html"
  },
  "downloaded_images": []
}