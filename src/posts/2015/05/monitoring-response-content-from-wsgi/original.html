<!DOCTYPE html>
<html class='v2' dir='ltr' lang='en'>
<head>
<link href='https://www.blogger.com/static/v1/widgets/2508126174-css_bundle_v2.css' rel='stylesheet' type='text/css'/>
<meta content='width=1100' name='viewport'/>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'/>
<meta content='blogger' name='generator'/>
<link href='http://blog.dscpl.com.au/favicon.ico' rel='icon' type='image/x-icon'/>
<link href='http://blog.dscpl.com.au/2015/05/monitoring-response-content-from-wsgi.html' rel='canonical'/>
<link rel="alternate" type="application/atom+xml" title="Graham Dumpleton - Atom" href="http://blog.dscpl.com.au/feeds/posts/default" />
<link rel="alternate" type="application/rss+xml" title="Graham Dumpleton - RSS" href="http://blog.dscpl.com.au/feeds/posts/default?alt=rss" />
<link rel="service.post" type="application/atom+xml" title="Graham Dumpleton - Atom" href="https://www.blogger.com/feeds/2363643920942057324/posts/default" />

<link rel="alternate" type="application/atom+xml" title="Graham Dumpleton - Atom" href="http://blog.dscpl.com.au/feeds/7325859312769573665/comments/default" />
<!--Can't find substitution for tag [blog.ieCssRetrofitLinks]-->
<meta content='http://blog.dscpl.com.au/2015/05/monitoring-response-content-from-wsgi.html' property='og:url'/>
<meta content='Monitoring the response content from a WSGI application.' property='og:title'/>
<meta content='I have been focusing in the last couple of posts  about the overheads of generating response content from a WSGI application as many separat...' property='og:description'/>
<title>Graham Dumpleton: Monitoring the response content from a WSGI application.</title>
<style id='page-skin-1' type='text/css'><!--
/*
-----------------------------------------------
Blogger Template Style
Name:     Simple
Designer: Blogger
URL:      www.blogger.com
----------------------------------------------- */
/* Content
----------------------------------------------- */
body {
font: normal normal 12px Arial, Tahoma, Helvetica, FreeSans, sans-serif;
color: #222222;
background: #66bbdd none repeat scroll top left;
padding: 0 40px 40px 40px;
}
html body .region-inner {
min-width: 0;
max-width: 100%;
width: auto;
}
h2 {
font-size: 22px;
}
a:link {
text-decoration:none;
color: #2187bb;
}
a:visited {
text-decoration:none;
color: #888888;
}
a:hover {
text-decoration:underline;
color: #32aaff;
}
.body-fauxcolumn-outer .fauxcolumn-inner {
background: transparent none repeat scroll top left;
_background-image: none;
}
.body-fauxcolumn-outer .cap-top {
position: absolute;
z-index: 1;
height: 400px;
width: 100%;
}
.body-fauxcolumn-outer .cap-top .cap-left {
width: 100%;
background: transparent none repeat-x scroll top left;
_background-image: none;
}
.content-outer {
-moz-box-shadow: 0 0 40px rgba(0, 0, 0, .15);
-webkit-box-shadow: 0 0 5px rgba(0, 0, 0, .15);
-goog-ms-box-shadow: 0 0 10px #333333;
box-shadow: 0 0 40px rgba(0, 0, 0, .15);
margin-bottom: 1px;
}
.content-inner {
padding: 10px 10px;
}
.content-inner {
background-color: #ffffff;
}
/* Header
----------------------------------------------- */
.header-outer {
background: transparent none repeat-x scroll 0 -400px;
_background-image: none;
}
.Header h1 {
font: normal normal 60px Arial, Tahoma, Helvetica, FreeSans, sans-serif;
color: #3299bb;
text-shadow: -1px -1px 1px rgba(0, 0, 0, .2);
}
.Header h1 a {
color: #3299bb;
}
.Header .description {
font-size: 140%;
color: #777777;
}
.header-inner .Header .titlewrapper {
padding: 22px 30px;
}
.header-inner .Header .descriptionwrapper {
padding: 0 30px;
}
/* Tabs
----------------------------------------------- */
.tabs-inner .section:first-child {
border-top: 1px solid #eeeeee;
}
.tabs-inner .section:first-child ul {
margin-top: -1px;
border-top: 1px solid #eeeeee;
border-left: 0 solid #eeeeee;
border-right: 0 solid #eeeeee;
}
.tabs-inner .widget ul {
background: #f5f5f5 url(https://resources.blogblog.com/blogblog/data/1kt/simple/gradients_light.png) repeat-x scroll 0 -800px;
_background-image: none;
border-bottom: 1px solid #eeeeee;
margin-top: 0;
margin-left: -30px;
margin-right: -30px;
}
.tabs-inner .widget li a {
display: inline-block;
padding: .6em 1em;
font: normal normal 14px Arial, Tahoma, Helvetica, FreeSans, sans-serif;
color: #999999;
border-left: 1px solid #ffffff;
border-right: 1px solid #eeeeee;
}
.tabs-inner .widget li:first-child a {
border-left: none;
}
.tabs-inner .widget li.selected a, .tabs-inner .widget li a:hover {
color: #000000;
background-color: #eeeeee;
text-decoration: none;
}
/* Columns
----------------------------------------------- */
.main-outer {
border-top: 0 solid #eeeeee;
}
.fauxcolumn-left-outer .fauxcolumn-inner {
border-right: 1px solid #eeeeee;
}
.fauxcolumn-right-outer .fauxcolumn-inner {
border-left: 1px solid #eeeeee;
}
/* Headings
----------------------------------------------- */
div.widget > h2,
div.widget h2.title {
margin: 0 0 1em 0;
font: normal bold 11px Arial, Tahoma, Helvetica, FreeSans, sans-serif;
color: #000000;
}
/* Widgets
----------------------------------------------- */
.widget .zippy {
color: #999999;
text-shadow: 2px 2px 1px rgba(0, 0, 0, .1);
}
.widget .popular-posts ul {
list-style: none;
}
/* Posts
----------------------------------------------- */
h2.date-header {
font: normal bold 11px Arial, Tahoma, Helvetica, FreeSans, sans-serif;
}
.date-header span {
background-color: transparent;
color: #222222;
padding: inherit;
letter-spacing: inherit;
margin: inherit;
}
.main-inner {
padding-top: 30px;
padding-bottom: 30px;
}
.main-inner .column-center-inner {
padding: 0 15px;
}
.main-inner .column-center-inner .section {
margin: 0 15px;
}
.post {
margin: 0 0 25px 0;
}
h3.post-title, .comments h4 {
font: normal normal 22px Arial, Tahoma, Helvetica, FreeSans, sans-serif;
margin: .75em 0 0;
}
.post-body {
font-size: 110%;
line-height: 1.4;
position: relative;
}
.post-body img, .post-body .tr-caption-container, .Profile img, .Image img,
.BlogList .item-thumbnail img {
padding: 2px;
background: #ffffff;
border: 1px solid #eeeeee;
-moz-box-shadow: 1px 1px 5px rgba(0, 0, 0, .1);
-webkit-box-shadow: 1px 1px 5px rgba(0, 0, 0, .1);
box-shadow: 1px 1px 5px rgba(0, 0, 0, .1);
}
.post-body img, .post-body .tr-caption-container {
padding: 5px;
}
.post-body .tr-caption-container {
color: #222222;
}
.post-body .tr-caption-container img {
padding: 0;
background: transparent;
border: none;
-moz-box-shadow: 0 0 0 rgba(0, 0, 0, .1);
-webkit-box-shadow: 0 0 0 rgba(0, 0, 0, .1);
box-shadow: 0 0 0 rgba(0, 0, 0, .1);
}
.post-header {
margin: 0 0 1.5em;
line-height: 1.6;
font-size: 90%;
}
.post-footer {
margin: 20px -2px 0;
padding: 5px 10px;
color: #666666;
background-color: #f9f9f9;
border-bottom: 1px solid #eeeeee;
line-height: 1.6;
font-size: 90%;
}
#comments .comment-author {
padding-top: 1.5em;
border-top: 1px solid #eeeeee;
background-position: 0 1.5em;
}
#comments .comment-author:first-child {
padding-top: 0;
border-top: none;
}
.avatar-image-container {
margin: .2em 0 0;
}
#comments .avatar-image-container img {
border: 1px solid #eeeeee;
}
/* Comments
----------------------------------------------- */
.comments .comments-content .icon.blog-author {
background-repeat: no-repeat;
background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEgAACxIB0t1+/AAAAAd0SU1FB9sLFwMeCjjhcOMAAAD+SURBVDjLtZSvTgNBEIe/WRRnm3U8RC1neQdsm1zSBIU9VVF1FkUguQQsD9ITmD7ECZIJSE4OZo9stoVjC/zc7ky+zH9hXwVwDpTAWWLrgS3QAe8AZgaAJI5zYAmc8r0G4AHYHQKVwII8PZrZFsBFkeRCABYiMh9BRUhnSkPTNCtVXYXURi1FpBDgArj8QU1eVXUzfnjv7yP7kwu1mYrkWlU33vs1QNu2qU8pwN0UpKoqokjWwCztrMuBhEhmh8bD5UDqur75asbcX0BGUB9/HAMB+r32hznJgXy2v0sGLBcyAJ1EK3LFcbo1s91JeLwAbwGYu7TP/3ZGfnXYPgAVNngtqatUNgAAAABJRU5ErkJggg==);
}
.comments .comments-content .loadmore a {
border-top: 1px solid #999999;
border-bottom: 1px solid #999999;
}
.comments .comment-thread.inline-thread {
background-color: #f9f9f9;
}
.comments .continue {
border-top: 2px solid #999999;
}
/* Accents
---------------------------------------------- */
.section-columns td.columns-cell {
border-left: 1px solid #eeeeee;
}
.blog-pager {
background: transparent none no-repeat scroll top center;
}
.blog-pager-older-link, .home-link,
.blog-pager-newer-link {
background-color: #ffffff;
padding: 5px;
}
.footer-outer {
border-top: 0 dashed #bbbbbb;
}
/* Mobile
----------------------------------------------- */
body.mobile  {
background-size: auto;
}
.mobile .body-fauxcolumn-outer {
background: transparent none repeat scroll top left;
}
.mobile .body-fauxcolumn-outer .cap-top {
background-size: 100% auto;
}
.mobile .content-outer {
-webkit-box-shadow: 0 0 3px rgba(0, 0, 0, .15);
box-shadow: 0 0 3px rgba(0, 0, 0, .15);
}
.mobile .tabs-inner .widget ul {
margin-left: 0;
margin-right: 0;
}
.mobile .post {
margin: 0;
}
.mobile .main-inner .column-center-inner .section {
margin: 0;
}
.mobile .date-header span {
padding: 0.1em 10px;
margin: 0 -10px;
}
.mobile h3.post-title {
margin: 0;
}
.mobile .blog-pager {
background: transparent none no-repeat scroll top center;
}
.mobile .footer-outer {
border-top: none;
}
.mobile .main-inner, .mobile .footer-inner {
background-color: #ffffff;
}
.mobile-index-contents {
color: #222222;
}
.mobile-link-button {
background-color: #2187bb;
}
.mobile-link-button a:link, .mobile-link-button a:visited {
color: #ffffff;
}
.mobile .tabs-inner .section:first-child {
border-top: none;
}
.mobile .tabs-inner .PageList .widget-content {
background-color: #eeeeee;
color: #000000;
border-top: 1px solid #eeeeee;
border-bottom: 1px solid #eeeeee;
}
.mobile .tabs-inner .PageList .widget-content .pagelist-arrow {
border-left: 1px solid #eeeeee;
}

--></style>
<style id='template-skin-1' type='text/css'><!--
body {
min-width: 1020px;
}
.content-outer, .content-fauxcolumn-outer, .region-inner {
min-width: 1020px;
max-width: 1020px;
_width: 1020px;
}
.main-inner .columns {
padding-left: 0px;
padding-right: 200px;
}
.main-inner .fauxcolumn-center-outer {
left: 0px;
right: 200px;
/* IE6 does not respect left and right together */
_width: expression(this.parentNode.offsetWidth -
parseInt("0px") -
parseInt("200px") + 'px');
}
.main-inner .fauxcolumn-left-outer {
width: 0px;
}
.main-inner .fauxcolumn-right-outer {
width: 200px;
}
.main-inner .column-left-outer {
width: 0px;
right: 100%;
margin-left: -0px;
}
.main-inner .column-right-outer {
width: 200px;
margin-right: -200px;
}
#layout {
min-width: 0;
}
#layout .content-outer {
min-width: 0;
width: 800px;
}
#layout .region-inner {
min-width: 0;
width: auto;
}
body#layout div.add_widget {
padding: 8px;
}
body#layout div.add_widget a {
margin-left: 32px;
}
--></style>
<link href='https://www.blogger.com/dyn-css/authorization.css?targetBlogID=2363643920942057324&amp;zx=8e425bf4-e933-49a5-a874-6a5d9cccad39' media='none' onload='if(media!=&#39;all&#39;)media=&#39;all&#39;' rel='stylesheet'/><noscript><link href='https://www.blogger.com/dyn-css/authorization.css?targetBlogID=2363643920942057324&amp;zx=8e425bf4-e933-49a5-a874-6a5d9cccad39' rel='stylesheet'/></noscript>
<meta name='google-adsense-platform-account' content='ca-host-pub-1556223355139109'/>
<meta name='google-adsense-platform-domain' content='blogspot.com'/>

<!-- data-ad-client=ca-pub-6433235630058377 -->

</head>
<body class='loading variant-pale'>
<div class='navbar section' id='navbar' name='Navbar'><div class='widget Navbar' data-version='1' id='Navbar1'><script type="text/javascript">
    function setAttributeOnload(object, attribute, val) {
      if(window.addEventListener) {
        window.addEventListener('load',
          function(){ object[attribute] = val; }, false);
      } else {
        window.attachEvent('onload', function(){ object[attribute] = val; });
      }
    }
  </script>
<div id="navbar-iframe-container"></div>
<script type="text/javascript" src="https://apis.google.com/js/platform.js"></script>
<script type="text/javascript">
      gapi.load("gapi.iframes:gapi.iframes.style.bubble", function() {
        if (gapi.iframes && gapi.iframes.getContext) {
          gapi.iframes.getContext().openChild({
              url: 'https://www.blogger.com/navbar/2363643920942057324?po\x3d7325859312769573665\x26origin\x3dhttp://blog.dscpl.com.au',
              where: document.getElementById("navbar-iframe-container"),
              id: "navbar-iframe"
          });
        }
      });
    </script><script type="text/javascript">
(function() {
var script = document.createElement('script');
script.type = 'text/javascript';
script.src = '//pagead2.googlesyndication.com/pagead/js/google_top_exp.js';
var head = document.getElementsByTagName('head')[0];
if (head) {
head.appendChild(script);
}})();
</script>
</div></div>
<div class='body-fauxcolumns'>
<div class='fauxcolumn-outer body-fauxcolumn-outer'>
<div class='cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left'>
<div class='fauxborder-right'></div>
<div class='fauxcolumn-inner'>
</div>
</div>
<div class='cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
</div>
<div class='content'>
<div class='content-fauxcolumns'>
<div class='fauxcolumn-outer content-fauxcolumn-outer'>
<div class='cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left'>
<div class='fauxborder-right'></div>
<div class='fauxcolumn-inner'>
</div>
</div>
<div class='cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
</div>
<div class='content-outer'>
<div class='content-cap-top cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left content-fauxborder-left'>
<div class='fauxborder-right content-fauxborder-right'></div>
<div class='content-inner'>
<header>
<div class='header-outer'>
<div class='header-cap-top cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left header-fauxborder-left'>
<div class='fauxborder-right header-fauxborder-right'></div>
<div class='region-inner header-inner'>
<div class='header section' id='header' name='Header'><div class='widget Header' data-version='1' id='Header1'>
<div id='header-inner'>
<div class='titlewrapper'>
<h1 class='title'>
<a href='http://blog.dscpl.com.au/'>
Graham Dumpleton
</a>
</h1>
</div>
<div class='descriptionwrapper'>
<p class='description'><span>
</span></p>
</div>
</div>
</div></div>
</div>
</div>
<div class='header-cap-bottom cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
</header>
<div class='tabs-outer'>
<div class='tabs-cap-top cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left tabs-fauxborder-left'>
<div class='fauxborder-right tabs-fauxborder-right'></div>
<div class='region-inner tabs-inner'>
<div class='tabs no-items section' id='crosscol' name='Cross-Column'></div>
<div class='tabs no-items section' id='crosscol-overflow' name='Cross-Column 2'></div>
</div>
</div>
<div class='tabs-cap-bottom cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
<div class='main-outer'>
<div class='main-cap-top cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left main-fauxborder-left'>
<div class='fauxborder-right main-fauxborder-right'></div>
<div class='region-inner main-inner'>
<div class='columns fauxcolumns'>
<div class='fauxcolumn-outer fauxcolumn-center-outer'>
<div class='cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left'>
<div class='fauxborder-right'></div>
<div class='fauxcolumn-inner'>
</div>
</div>
<div class='cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
<div class='fauxcolumn-outer fauxcolumn-left-outer'>
<div class='cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left'>
<div class='fauxborder-right'></div>
<div class='fauxcolumn-inner'>
</div>
</div>
<div class='cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
<div class='fauxcolumn-outer fauxcolumn-right-outer'>
<div class='cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left'>
<div class='fauxborder-right'></div>
<div class='fauxcolumn-inner'>
</div>
</div>
<div class='cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
<!-- corrects IE6 width calculation -->
<div class='columns-inner'>
<div class='column-center-outer'>
<div class='column-center-inner'>
<div class='main section' id='main' name='Main'><div class='widget Blog' data-version='1' id='Blog1'>
<div class='blog-posts hfeed'>

          <div class="date-outer">
        
<h2 class='date-header'><span>Saturday, May 23, 2015</span></h2>

          <div class="date-posts">
        
<div class='post-outer'>
<div class='post hentry uncustomized-post-template' itemprop='blogPost' itemscope='itemscope' itemtype='http://schema.org/BlogPosting'>
<meta content='2363643920942057324' itemprop='blogId'/>
<meta content='7325859312769573665' itemprop='postId'/>
<a name='7325859312769573665'></a>
<h3 class='post-title entry-title' itemprop='name'>
Monitoring the response content from a WSGI application.
</h3>
<div class='post-header'>
<div class='post-header-line-1'></div>
</div>
<div class='post-body entry-content' id='post-body-7325859312769573665' itemprop='description articleBody'>
<p>I have been focusing in the last couple of <a href="http://blog.dscpl.com.au/2015/05/returning-string-as-iterable-from-wsgi.html">posts</a> about the overheads of generating response content from a WSGI application as many separate blocks rather than as one large block. This has illustrated how there can be quite marked differences between different WSGI servers and even with a specific WSGI server depending on how it is configured or integrated into an overall architecture.&#160;</p>
<p>In this post I want to look at how we could actually add monitoring which could track how much data is actually being returned in a response and how many blocks it was broken up into. We can also track how much time was being spent by the WSGI server trying to write that data back to the HTTP client.</p>
<h1>Monitoring overall response time</h1>
<p>Previously I presented a decorator which could be applied to a WSGI application to time the overall response time. That is, how long it took for the complete handling of the request, including the processing of the request content, as well as the generation of the response and the writing of it back to the HTTP client.</p>
<p>The code for the decorator was:</p>
<blockquote>
<pre>from __future__ import print_function</pre>
<pre>from wrapt import decorator, ObjectProxy<br />from timeit import default_timer<br /><br />class WSGIApplicationIterable1(ObjectProxy):</pre>
<pre>    def __init__(self, wrapped, name, start):<br />&#160;     &#160; super(WSGIApplicationIterable1, self).__init__(wrapped)<br />&#160; &#160;     self._self_name = name<br />&#160; &#160;     self._self_start = start</pre>
<pre>    def close(self):<br />&#160;     &#160; if hasattr(self.__wrapped__, 'close'):<br />&#160;     &#160; &#160; &#160; self.__wrapped__.close()</pre>
<pre>&#160;     &#160; duration = default_timer() - self._self_start<br />&#160;     &#160; print('finish %s %.3fms' % (self._self_name, duration*1000.0))</pre>
<pre>@decorator<br />def timed_wsgi_application1(wrapped, instance, args, kwargs):<br />&#160; &#160; name = wrapped.__name__</pre>
<pre>&#160; &#160; start = default_timer()<br />&#160; &#160; print('start', name)</pre>
<pre>&#160; &#160; try:<br />&#160; &#160; &#160; &#160; return WSGIApplicationIterable1(wrapped(*args, **kwargs), name, start)</pre>
<pre>&#160; &#160; except:<br />&#160; &#160; &#160; &#160; duration = default_timer() - start<br />&#160; &#160; &#160; &#160; print('finish %s %.3fms' % (name, duration*1000.0))<br />&#160; &#160; &#160; &#160; raise</pre>
</blockquote>
<p>Although described as a decorator, this is actually implementing a form of WSGI middleware. In this case the middleware was intercepting the act of calling the WSGI application to handle the request and the finalisation of the request through the calling of any 'close()' method of the returned iterable.</p>
<p>What we didn't intercept in any way was the request content or response content. So what we want to do now is extend this to intercept the response content as it is generated so that we can count how many bytes are being generated and as how many blocks.</p>
<h1>Intercepting the response content</h1>
<p>To understand what is now needed to intercept the response content we need to look at how a WSGI server actually interfaces with the WSGI application. This interaction can be seen in the sample CGI to WSGI bridge presented in the <a href="https://www.python.org/dev/peps/pep-3333/#the-server-gateway-side">WSGI specification</a>.</p>
<p>The key part of the sample code presented in the WSGI specification is as follows and has three parts.</p>
<blockquote>
<pre>&#160; &#160; result = application(environ, start_response)</pre>
<pre>&#160; &#160; try:<br />&#160; &#160; &#160; &#160; for data in result:<br />&#160; &#160; &#160; &#160; &#160; &#160; if data:<br /> &#160; &#160;&#160; &#160;&#160; &#160;&#160; &#160;&#160; &#160;write(data)<br /> &#160; &#160;&#160; &#160;&#160; &#160;&#160; if not headers_sent:<br /> &#160; &#160;&#160; &#160;&#160; &#160;&#160; &#160;&#160; &#160;write('')</pre>
<pre>&#160; &#160; finally:<br /> &#160; &#160;&#160; &#160; if hasattr(result, 'close'):<br /> &#160; &#160;&#160; &#160;&#160;   &#160;result.close()</pre>
</blockquote>
<p>The first part is the calling of the WSGI application. It is the result of this call which has been wrapped by our timing wrapper.</p>
<p>The result returned is then iterated over to yield each data block making up the response, with it being written back to the HTTP client.</p>
<p>Finally, the 'close()' method is then called on the iterable. The 'close()' method of the iterable is called whether or not the iterable was completely consumed. The iterable may not be completely consumed if while generating any response an exception occurred, or if when writing the response back to the HTTP client an error occurred, such as the connection being dropped.</p>
<p>In the middleware wrapper we are so far intercepting the original WSGI application call and the call to 'close()'.</p>
<p>In order to now intercept the response content we need to intercept the creation of the iterator object from the iterable when the 'in' statement is applied to it in the loop.</p>
<p>To do that, we need to intercept the special '__iter__()' method of the iterable. As it stands right now, due to the wrapper for the iterable being implemented as a derived class of the 'ObjectProxy' class from the 'wrapt' package, the call of the '__iter__()' method is being automatically applied to the original wrapped iterable. In effect the object proxy is doing:</p>
<blockquote>
<pre>&#160; &#160; def __iter__(self):<br />&#160; &#160; &#160; &#160; return iter(self.__wrapped__)</pre>
</blockquote>
<p>We want to do more than simply process in some way the iterator object itself. Instead we want to process each yielded item. For this we need to iterate over the original wrapped iterable object ourselves, turning the '__iter__()' method into a generator function. This can be done as:</p>
<blockquote>
<pre>&#160; &#160; def __iter__(self):<br />&#160; &#160; &#160; &#160; for data in self.__wrapped__:<br />&#160; &#160; &#160; &#160; &#160; &#160; yield data</pre>
</blockquote>
<h1>The archaic write() callback</h1>
<p>The job of intercepting the response content seems simple enough but simply overriding '__iter__()' is unfortunately not enough if you want a completely correct WSGI middleware.&#160;This is because returning an iterable is not the only way that it is possible to return response content.</p>
<p>To support certain older style Python web applications that preceded the WSGI specification, another way of generating response content is supported. This is via a 'write()' callback function which is returned by the 'start_response()' function when called by the WSGI application.</p>
<p>When this 'write()' callback function is used to provide the response content, then the iterable returned by the WSGI application would normally be an empty list. The code above would therefore never actually see any response content.</p>
<p>I have blogged previously about this <a href="http://blog.dscpl.com.au/2012/10/wsgi-middleware-and-hidden-write.html">hidden 'write()' callback</a> and although a correct WSGI middleware should support it, for the purposes of this analysis I am going to ignore it.</p>
<p>Ignoring the 'write()' callback function will not affect the operation of the wrapped WSGI application, but it means that if the 'write()' callback function were used, we wouldn't report anything about the response content generated that way.</p>
<h1>Overheads of adding monitoring</h1>
<p>Now, before we get started on adding to the basic loop for intercepting the actual response content, it is important to highlight that monitoring isn't necessarily free.</p>
<p>In our original timing decorator for the WSGI application we introduced a number of additional function calls, however that number was fixed for each request handled. The additional overhead from these extra calls would be acceptable so long as what those calls themselves did wasn't excessive.</p>
<p>When we start talking about intercepting the request content so as to accumulate metric information about the data being generated for the response, we would be adding extra calls and processing for every distinct data block.</p>
<p>We have already seen how an excessive number of distinct data blocks in a worst case scenario can be a problem with some WSGI servers. We therefore have to be very careful, as although the additional overhead of the monitoring code may not present a problem when there are a small number of data blocks, the extra work being performed could exacerbate the worst case scenario and severely affect the responsiveness of the monitored application at the one time the server is already stressed and so when you don't want that to occur.</p>
<p>Ideally the generation of metric information about a request would be embedded within the WSGI server itself so as to avoid the need to add in special wrappers which add to the number of intermediate calls being made. Unfortunately the majority of WSGI servers provide no such functionality. The next best alternative is to consider writing any such monitoring wrappers as a Python C extension to limit the potential overhead.</p>
<p>However monitoring is added, one key thing to try and always avoid is doing too much processing during the life of the request itself. Any extra processing that is done during the request will obviously add to the response time as seen by the user. Thus you should try and do the absolute minimum while the request is being handled and try to defer more complex processing based on any raw data collected, until after the request has completed.</p>
<p>By doing this the impact on the response time is at least reduced, albeit that it still potentially comes at a cost. This extra cost may be in extra memory usage due to needing to hold raw data for processing at the end of the request, but also in additional CPU usage from doing that processing.</p>
<p>Deferring complex processing until the end of the request will also still keep that request thread busy until it is complete, preventing it from being released to handle a subsequent request, be that a request on a totally distinct connection or a request on a keep alive connection. This delayed release of the request thread can therefore potentially cause a reduction in available server capacity.</p>
<p>Overall, monitoring is a bit of a balancing act. You can't avoid all overheads from monitoring and so when monitoring is first added you may see a reduction in performance as a result. The visibility one gets from adding monitoring though allows you to more easily identify potential issues and fix them. You therefore quite quickly get to a better point than where you were originally without monitoring and so the hit you take from the monitoring is worth it.</p>
<p>You could well at this point remove the monitoring and so eliminate the overheads once more, but you would then be running in the dark again and so have no idea when you introduce some bad code once more. Best to accept the initial overheads and just get on with improving your code from what you learn. Just be careful in designing the monitoring code to reduce the overheads as much as possible.</p>
<p>That all said, let's try and continue by calculating a baseline to gauge how much overhead any monitoring may be adding. For that we can first try to use our prior test example whereby we returned a large string as the iterable.</p>
<blockquote>
<pre>from timer1 import timed_wsgi_application1</pre>
<pre>@timed_wsgi_application1<br />def application(environ, start_response):<br />&#160; &#160; status = '200 OK'<br /> &#160; &#160;output = 100000 * b'Hello World!'</pre>
<pre>&#160; &#160;response_headers = [('Content-type', 'text/plain'),<br /> &#160; &#160;&#160; &#160;('Content-Length', str(len(output)))]<br /> &#160; &#160;start_response(status, response_headers)</pre>
<pre>&#160; &#160;return output</pre>
</blockquote>
<p>With our original decorator which measures just the length of time spent in the WSGI application, when we use mod_wsgi-express this time we get:</p>
<blockquote>
<pre>start application<br />finish application 6269.062ms</pre>
</blockquote>
<p>If we override the '__iter__()' method to introduce the loop but not do any processing:</p>
<blockquote>
<pre>&#160; &#160; def __iter__(self):<br />&#160; &#160; &#160; &#160; for data in self.__wrapped__:<br />&#160; &#160; &#160; &#160; &#160; &#160; yield data</pre>
</blockquote>
<p>we now get:</p>
<blockquote>
<pre>start application<br />finish application 6291.978ms</pre>
</blockquote>
<p>Not much difference, but a further big warning has to be made.</p>
<p>The problem with making minor changes like this and triggering one off test runs is that it is actually really hard to truly gauge the impact of the change, especially in a case like this where one was already stressing the WSGI server quite severely, with CPU usage peaking up towards 100%.</p>
<p>This is because when a system is being stressed to the maximum, the variability between the results from one run to the next can be quite marked and so when there isn't much difference the results for the two variations on the code can actually overlap as the result values bounce around.</p>
<p>Although the normal approach to eliminating such variability is to run the benchmark test many many times and try and determine some sort of average, or at least eliminate outliers, this doesn't generally help in a situation where the WSGI server is being stressed to breaking point.</p>
<p>This is actually one of the big mistakes people make when trying to benchmark WSGI servers to try and work out which may be able to handle the greatest throughput. That is, they just flood the WSGI servers with requests such that they are overloaded, which only serves to generate results which are quite unpredictable.</p>
<p>When trying to evaluate WSGI server performance it is better to evaluate how it behaves at a level of about 50% capacity utilisation. This is a level whereby you aren't triggering pathological cases of performance degradation through overloading, yet still gives you some measure of head room for transient peaks in the request throughput.</p>
<p>If you are constantly pushing high levels of capacity utilisation in a WSGI server then you should really be looking at scaling out horizontally to ensure you have the spare capacity to meet demands as they arise, rather than running the WSGI server at breaking point.</p>
<p>So trying to gauge overheads at this point is partly a pointless exercise with the test we have, so lets just get on with implementing the code instead and we will revisit the issue of measuring overhead later.</p>
<h1>Counting writes and bytes</h1>
<p>The initial change we were therefore after was tracking how&#160;much data is actually being returned in a response and how many blocks it was broken up into. Overriding the '__iter__()' method we can do this using:</p>
<blockquote>
<pre>class WSGIApplicationIterable2(ObjectProxy):</pre>
<pre>&#160; &#160; def __init__(self, wrapped, name, start):<br />&#160; &#160;&#160; &#160; &#160;super(WSGIApplicationIterable2, self).__init__(wrapped)<br />&#160; &#160; &#160; &#160; self._self_name = name<br />&#160; &#160; &#160; &#160; self._self_start = start<br />&#160; &#160; &#160; &#160; self._self_count = 0<br />&#160; &#160; &#160; &#160; self._self_bytes = 0</pre>
<pre>&#160; &#160; def __iter__(self):<br />&#160; &#160; &#160; &#160; count = 0<br />&#160; &#160; &#160; &#160; bytes = 0<br />&#160; &#160; &#160; &#160; try:<br />&#160; &#160; &#160; &#160; &#160; &#160; for data in self.__wrapped__:<br />&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; yield data<br />&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; count += 1<br />&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; bytes += len(data)<br />&#160; &#160; &#160; &#160; finally:<br />&#160; &#160; &#160; &#160; &#160; &#160; self._self_count = count<br />&#160; &#160; &#160; &#160; &#160; &#160; self._self_bytes = bytes</pre>
<pre>&#160; &#160; def close(self):<br />&#160; &#160; &#160; &#160; if hasattr(self.__wrapped__, 'close'):<br />&#160; &#160; &#160; &#160; &#160; &#160; self.__wrapped__.close()</pre>
<pre>&#160; &#160; &#160; &#160; duration = default_timer() - self._self_start<br />&#160; &#160; &#160; &#160; print('write %s blocks %s bytes' % (self._self_count,&#160;self._self_bytes))<br />&#160; &#160; &#160; &#160; print('finish %s %.3fms' % (self._self_name, duration*1000.0))</pre>
</blockquote>
<p>Run this with our test example where a string was returned as the iterable rather than a list of strings, we get:</p>
<blockquote>
<pre>start application<br />write 1200000 blocks 1200000 bytes<br />finish application 5499.676ms</pre>
</blockquote>
<p>This is in contrast to what we would hope to see, which is a small as possible number of blocks, and even just the one block if that was achievable without blowing out memory usage.</p>
<blockquote>
<pre>start application<br />write 1 blocks 1200000 bytes<br />finish application 4.867ms</pre>
</blockquote>
<p>What we are obviously hoping for here is a low number of blocks, or at least a high average number of bytes per block. If the average number of bytes per block is very low, then it would be worthy of further inspection.</p>
<h1>Time taken to write output</h1>
<p>Tracking the number of bytes written and the number of blocks can highlight potential issues, but it doesn't actually tell us how long was spent writing the data back to the HTTP client. Knowing the time taken will help us confirm whether the response being returned as a large number of blocks is an issue or not. To capture information about the amount of time taken we can use:</p>
<blockquote>
<pre>class WSGIApplicationIterable3(ObjectProxy):</pre>
<pre>&#160; &#160; def __init__(self, wrapped, name, start):<br />&#160; &#160; &#160; &#160; super(WSGIApplicationIterable3, self).__init__(wrapped)<br />&#160; &#160; &#160; &#160; self._self_name = name<br />&#160; &#160; &#160; &#160; self._self_start = start<br />&#160; &#160; &#160; &#160; self._self_time = 0.0<br />&#160; &#160; &#160; &#160; self._self_count = 0<br />&#160; &#160; &#160; &#160; self._self_bytes = 0</pre>
<pre>&#160; &#160; def __iter__(self):<br />&#160; &#160; &#160; &#160; time = 0.0<br />&#160; &#160; &#160; &#160; start = 0.0<br />&#160; &#160; &#160; &#160; count = 0<br />&#160; &#160; &#160; &#160; bytes = 0<br />&#160; &#160; &#160; &#160; try:<br />&#160; &#160; &#160; &#160; &#160; &#160; for data in self.__wrapped__:<br />&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; start = default_timer()<br />&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; yield data<br />&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; finish = default_timer()&#160;<br />&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if finish &gt; start:<br />&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; time += (finish - start)<br />&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; start = 0.0<br />&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; count += 1<br />&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; bytes += len(data)<br />&#160; &#160; &#160; &#160; finally:<br />&#160; &#160; &#160; &#160; &#160; &#160; if start:<br />&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; finish = default_timer()<br />&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if finish &gt; start:<br />&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; time += (finish - start)</pre>
<pre>&#160; &#160; &#160; &#160; self._self_time = time<br />&#160; &#160; &#160; &#160; self._self_count = count<br />&#160; &#160; &#160; &#160; self._self_bytes = bytes</pre>
<pre>&#160; &#160; def close(self):<br />&#160; &#160; &#160; &#160; if hasattr(self.__wrapped__, 'close'):<br />&#160; &#160; &#160; &#160; &#160; &#160; &#160; self.__wrapped__.close()</pre>
<pre>&#160; &#160; &#160; &#160; duration = default_timer() - self._self_start<br />&#160; &#160; &#160; &#160; print('write %s blocks %s bytes %.3fms' % (self._self_count,<br />&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; self._self_bytes, self._self_time*1000.0))<br />&#160; &#160; &#160; &#160; print('finish %s %.3fms' % (self._self_name, duration*1000.0))</pre>
</blockquote>
<p>In this version of the wrapper we time how long it took to yield each value from the loop. This has the affect of timing how long it took any outer layer, in this case how long the WSGI server took, to process and write the block of data back to the HTTP client.</p>
<p>Running our test example now we get:</p>
<blockquote>
<pre>start application<br />write 1200000 blocks 1200000 bytes 6654.018ms<br />finish application 7812.504ms</pre>
</blockquote>
<p>We can therefore see that the time taken in writing out the actual data took a large proportion of the overall response time. In this case the actual test example wasn't itself doing much work so that would have been the case anyway, but the magnitude of the amount of time spent writing the response in conjunction with the number of blocks is the concern.</p>
<p>Do though keep in mind that even if you were writing as few blocks as possible that if a large amount of data was involved, that the WSGI server could itself block when writing to the socket if the HTTP client wasn't reading the data quickly enough.</p>
<p>The time taken can therefore be helpful in pointing out other issues as well and not just the cumulative impact of writing many small blocks of data.</p>
<p>The big question now is how you turn such information into actionable data.</p>
<p>Using print statements to output timing values is all well and good in a test scenario when playing around with WSGI servers, but it isn't of any use in a production environment. The next step therefore is to look at how one can capture such information in bulk in the context of a production environment and whether it still remains useful at that point.</p>
<div style='clear: both;'></div>
</div>
<div class='post-footer'>
<div class='post-footer-line post-footer-line-1'>
<span class='post-author vcard'>
Posted by
<span class='fn' itemprop='author' itemscope='itemscope' itemtype='http://schema.org/Person'>
<meta content='https://www.blogger.com/profile/13609779138164842374' itemprop='url'/>
<a class='g-profile' href='https://www.blogger.com/profile/13609779138164842374' rel='author' title='author profile'>
<span itemprop='name'>Graham Dumpleton</span>
</a>
</span>
</span>
<span class='post-timestamp'>
at
<meta content='http://blog.dscpl.com.au/2015/05/monitoring-response-content-from-wsgi.html' itemprop='url'/>
<a class='timestamp-link' href='http://blog.dscpl.com.au/2015/05/monitoring-response-content-from-wsgi.html' rel='bookmark' title='permanent link'><abbr class='published' itemprop='datePublished' title='2015-05-23T21:41:00+10:00'>9:41&#8239;PM</abbr></a>
</span>
<span class='post-comment-link'>
</span>
<span class='post-icons'>
<span class='item-action'>
<a href='https://www.blogger.com/email-post/2363643920942057324/7325859312769573665' title='Email Post'>
<img alt='' class='icon-action' height='13' src='https://resources.blogblog.com/img/icon18_email.gif' width='18'/>
</a>
</span>
</span>
<div class='post-share-buttons goog-inline-block'>
<a class='goog-inline-block share-button sb-email' href='https://www.blogger.com/share-post.g?blogID=2363643920942057324&postID=7325859312769573665&target=email' target='_blank' title='Email This'><span class='share-button-link-text'>Email This</span></a><a class='goog-inline-block share-button sb-blog' href='https://www.blogger.com/share-post.g?blogID=2363643920942057324&postID=7325859312769573665&target=blog' onclick='window.open(this.href, "_blank", "height=270,width=475"); return false;' target='_blank' title='BlogThis!'><span class='share-button-link-text'>BlogThis!</span></a><a class='goog-inline-block share-button sb-twitter' href='https://www.blogger.com/share-post.g?blogID=2363643920942057324&postID=7325859312769573665&target=twitter' target='_blank' title='Share to X'><span class='share-button-link-text'>Share to X</span></a><a class='goog-inline-block share-button sb-facebook' href='https://www.blogger.com/share-post.g?blogID=2363643920942057324&postID=7325859312769573665&target=facebook' onclick='window.open(this.href, "_blank", "height=430,width=640"); return false;' target='_blank' title='Share to Facebook'><span class='share-button-link-text'>Share to Facebook</span></a><a class='goog-inline-block share-button sb-pinterest' href='https://www.blogger.com/share-post.g?blogID=2363643920942057324&postID=7325859312769573665&target=pinterest' target='_blank' title='Share to Pinterest'><span class='share-button-link-text'>Share to Pinterest</span></a>
</div>
</div>
<div class='post-footer-line post-footer-line-2'>
<span class='post-labels'>
Labels:
<a href='http://blog.dscpl.com.au/search/label/python' rel='tag'>python</a>,
<a href='http://blog.dscpl.com.au/search/label/wsgi' rel='tag'>wsgi</a>
</span>
</div>
<div class='post-footer-line post-footer-line-3'>
<span class='post-location'>
</span>
</div>
</div>
</div>
<div class='comments' id='comments'>
<a name='comments'></a>
<h4>No comments:</h4>
<div id='Blog1_comments-block-wrapper'>
<dl class='avatar-comment-indent' id='comments-block'>
</dl>
</div>
<p class='comment-footer'>
<a href='https://www.blogger.com/comment/fullpage/post/2363643920942057324/7325859312769573665' onclick=''>Post a Comment</a>
</p>
</div>
</div>

        </div></div>
      
</div>
<div class='blog-pager' id='blog-pager'>
<span id='blog-pager-newer-link'>
<a class='blog-pager-newer-link' href='http://blog.dscpl.com.au/2015/05/performance-monitoring-of-real-wsgi.html' id='Blog1_blog-pager-newer-link' title='Newer Post'>Newer Post</a>
</span>
<span id='blog-pager-older-link'>
<a class='blog-pager-older-link' href='http://blog.dscpl.com.au/2015/05/returning-string-as-iterable-from-wsgi.html' id='Blog1_blog-pager-older-link' title='Older Post'>Older Post</a>
</span>
<a class='home-link' href='http://blog.dscpl.com.au/'>Home</a>
</div>
<div class='clear'></div>
<div class='post-feeds'>
<div class='feed-links'>
Subscribe to:
<a class='feed-link' href='http://blog.dscpl.com.au/feeds/7325859312769573665/comments/default' target='_blank' type='application/atom+xml'>Post Comments (Atom)</a>
</div>
</div>
</div></div>
</div>
</div>
<div class='column-left-outer'>
<div class='column-left-inner'>
<aside>
</aside>
</div>
</div>
<div class='column-right-outer'>
<div class='column-right-inner'>
<aside>
<div class='sidebar section' id='sidebar-right-1'><div class='widget Profile' data-version='1' id='Profile1'>
<h2>About Me</h2>
<div class='widget-content'>
<dl class='profile-datablock'>
<dt class='profile-data'>
<a class='profile-name-link g-profile' href='https://www.blogger.com/profile/13609779138164842374' rel='author' style='background-image: url(//www.blogger.com/img/logo-16.png);'>
Graham Dumpleton
</a>
</dt>
</dl>
<a class='profile-link' href='https://www.blogger.com/profile/13609779138164842374' rel='author'>View my complete profile</a>
<div class='clear'></div>
</div>
</div><div class='widget PageList' data-version='1' id='PageList1'>
<h2>Quick Links</h2>
<div class='widget-content'>
<ul>
<li>
<a href='http://blog.dscpl.com.au/p/decorators-and-monkey-patching.html'>Decorators and monkey patching.</a>
</li>
<li>
<a href='http://blog.dscpl.com.au/p/using-python-with-docker.html'>Using Python with Docker.</a>
</li>
</ul>
<div class='clear'></div>
</div>
</div><div class='widget BlogArchive' data-version='1' id='BlogArchive1'>
<h2>Blog Archive</h2>
<div class='widget-content'>
<div id='ArchiveList'>
<div id='BlogArchive1_ArchiveList'>
<select id='BlogArchive1_ArchiveMenu'>
<option value=''>Blog Archive</option>
<option value='http://blog.dscpl.com.au/2019/01/'>January (3)</option>
<option value='http://blog.dscpl.com.au/2018/12/'>December (4)</option>
<option value='http://blog.dscpl.com.au/2018/10/'>October (1)</option>
<option value='http://blog.dscpl.com.au/2018/04/'>April (1)</option>
<option value='http://blog.dscpl.com.au/2018/01/'>January (1)</option>
<option value='http://blog.dscpl.com.au/2017/04/'>April (1)</option>
<option value='http://blog.dscpl.com.au/2016/12/'>December (2)</option>
<option value='http://blog.dscpl.com.au/2016/08/'>August (1)</option>
<option value='http://blog.dscpl.com.au/2016/07/'>July (1)</option>
<option value='http://blog.dscpl.com.au/2016/04/'>April (2)</option>
<option value='http://blog.dscpl.com.au/2016/03/'>March (1)</option>
<option value='http://blog.dscpl.com.au/2016/02/'>February (2)</option>
<option value='http://blog.dscpl.com.au/2016/01/'>January (3)</option>
<option value='http://blog.dscpl.com.au/2015/12/'>December (6)</option>
<option value='http://blog.dscpl.com.au/2015/10/'>October (1)</option>
<option value='http://blog.dscpl.com.au/2015/08/'>August (1)</option>
<option value='http://blog.dscpl.com.au/2015/07/'>July (2)</option>
<option value='http://blog.dscpl.com.au/2015/06/'>June (5)</option>
<option value='http://blog.dscpl.com.au/2015/05/'>May (7)</option>
<option value='http://blog.dscpl.com.au/2015/04/'>April (4)</option>
<option value='http://blog.dscpl.com.au/2015/03/'>March (4)</option>
<option value='http://blog.dscpl.com.au/2015/01/'>January (2)</option>
<option value='http://blog.dscpl.com.au/2014/12/'>December (4)</option>
<option value='http://blog.dscpl.com.au/2014/11/'>November (1)</option>
<option value='http://blog.dscpl.com.au/2014/09/'>September (7)</option>
<option value='http://blog.dscpl.com.au/2014/08/'>August (1)</option>
<option value='http://blog.dscpl.com.au/2014/05/'>May (1)</option>
<option value='http://blog.dscpl.com.au/2014/04/'>April (1)</option>
<option value='http://blog.dscpl.com.au/2014/02/'>February (4)</option>
<option value='http://blog.dscpl.com.au/2014/01/'>January (8)</option>
<option value='http://blog.dscpl.com.au/2013/12/'>December (1)</option>
<option value='http://blog.dscpl.com.au/2012/12/'>December (1)</option>
<option value='http://blog.dscpl.com.au/2012/10/'>October (4)</option>
<option value='http://blog.dscpl.com.au/2012/08/'>August (1)</option>
<option value='http://blog.dscpl.com.au/2011/11/'>November (1)</option>
<option value='http://blog.dscpl.com.au/2011/10/'>October (1)</option>
<option value='http://blog.dscpl.com.au/2011/09/'>September (1)</option>
<option value='http://blog.dscpl.com.au/2011/03/'>March (1)</option>
<option value='http://blog.dscpl.com.au/2011/01/'>January (5)</option>
<option value='http://blog.dscpl.com.au/2010/12/'>December (2)</option>
<option value='http://blog.dscpl.com.au/2010/10/'>October (1)</option>
<option value='http://blog.dscpl.com.au/2010/08/'>August (2)</option>
<option value='http://blog.dscpl.com.au/2010/06/'>June (2)</option>
<option value='http://blog.dscpl.com.au/2010/05/'>May (2)</option>
<option value='http://blog.dscpl.com.au/2010/04/'>April (1)</option>
<option value='http://blog.dscpl.com.au/2010/03/'>March (3)</option>
<option value='http://blog.dscpl.com.au/2009/11/'>November (4)</option>
<option value='http://blog.dscpl.com.au/2009/10/'>October (3)</option>
<option value='http://blog.dscpl.com.au/2009/09/'>September (1)</option>
<option value='http://blog.dscpl.com.au/2009/08/'>August (3)</option>
<option value='http://blog.dscpl.com.au/2009/05/'>May (2)</option>
<option value='http://blog.dscpl.com.au/2009/04/'>April (5)</option>
<option value='http://blog.dscpl.com.au/2009/03/'>March (5)</option>
<option value='http://blog.dscpl.com.au/2009/02/'>February (1)</option>
<option value='http://blog.dscpl.com.au/2008/12/'>December (2)</option>
<option value='http://blog.dscpl.com.au/2008/08/'>August (1)</option>
<option value='http://blog.dscpl.com.au/2008/03/'>March (1)</option>
<option value='http://blog.dscpl.com.au/2007/11/'>November (2)</option>
<option value='http://blog.dscpl.com.au/2007/10/'>October (3)</option>
<option value='http://blog.dscpl.com.au/2007/09/'>September (3)</option>
<option value='http://blog.dscpl.com.au/2007/08/'>August (1)</option>
<option value='http://blog.dscpl.com.au/2007/07/'>July (2)</option>
<option value='http://blog.dscpl.com.au/2007/03/'>March (2)</option>
</select>
</div>
</div>
<div class='clear'></div>
</div>
</div><div class='widget Label' data-version='1' id='Label1'>
<h2>Labels</h2>
<div class='widget-content list-label-widget-content'>
<ul>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/python'>python</a>
<span dir='ltr'>(111)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/mod_wsgi'>mod_wsgi</a>
<span dir='ltr'>(86)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/wsgi'>wsgi</a>
<span dir='ltr'>(58)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/apache'>apache</a>
<span dir='ltr'>(35)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/docker'>docker</a>
<span dir='ltr'>(34)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/openshift'>openshift</a>
<span dir='ltr'>(26)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/decorators'>decorators</a>
<span dir='ltr'>(15)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/django'>django</a>
<span dir='ltr'>(13)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/kubernetes'>kubernetes</a>
<span dir='ltr'>(12)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/mod_python'>mod_python</a>
<span dir='ltr'>(9)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/red%20hat'>red hat</a>
<span dir='ltr'>(9)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/ipython'>ipython</a>
<span dir='ltr'>(7)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/jupyterhub'>jupyterhub</a>
<span dir='ltr'>(7)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/new%20relic'>new relic</a>
<span dir='ltr'>(6)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/wrapt'>wrapt</a>
<span dir='ltr'>(6)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/pycon'>pycon</a>
<span dir='ltr'>(5)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/s2i'>s2i</a>
<span dir='ltr'>(4)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/gunicorn'>gunicorn</a>
<span dir='ltr'>(3)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/uWSGI'>uWSGI</a>
<span dir='ltr'>(3)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/datadog'>datadog</a>
<span dir='ltr'>(2)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/nginx'>nginx</a>
<span dir='ltr'>(2)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/statsd'>statsd</a>
<span dir='ltr'>(2)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/web2py'>web2py</a>
<span dir='ltr'>(2)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/async'>async</a>
<span dir='ltr'>(1)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/dyndns53'>dyndns53</a>
<span dir='ltr'>(1)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/fastcgi'>fastcgi</a>
<span dir='ltr'>(1)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/heroku'>heroku</a>
<span dir='ltr'>(1)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/jupyter'>jupyter</a>
<span dir='ltr'>(1)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/lektor'>lektor</a>
<span dir='ltr'>(1)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/php'>php</a>
<span dir='ltr'>(1)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/shiv'>shiv</a>
<span dir='ltr'>(1)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/testing'>testing</a>
<span dir='ltr'>(1)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/tornado'>tornado</a>
<span dir='ltr'>(1)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/warpdrive'>warpdrive</a>
<span dir='ltr'>(1)</span>
</li>
<li>
<a dir='ltr' href='http://blog.dscpl.com.au/search/label/zipapp'>zipapp</a>
<span dir='ltr'>(1)</span>
</li>
</ul>
<div class='clear'></div>
</div>
</div></div>
</aside>
</div>
</div>
</div>
<div style='clear: both'></div>
<!-- columns -->
</div>
<!-- main -->
</div>
</div>
<div class='main-cap-bottom cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
<footer>
<div class='footer-outer'>
<div class='footer-cap-top cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left footer-fauxborder-left'>
<div class='fauxborder-right footer-fauxborder-right'></div>
<div class='region-inner footer-inner'>
<div class='foot section' id='footer-1'><div class='widget AdSense' data-version='1' id='AdSense1'>
<div class='widget-content'>
<script type="text/javascript"><!--
google_ad_client="pub-6433235630058377";
google_ad_host="pub-1556223355139109";
google_ad_width=120;
google_ad_height=600;
google_ad_format="120x600_as";
google_ad_type="text";
google_ad_host_channel="0001";
google_color_border="FFFFFF";
google_color_bg="FFFFFF";
google_color_link="999999";
google_color_url="5588AA";
google_color_text="666666";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<div class='clear'></div>
</div>
</div></div>
<table border='0' cellpadding='0' cellspacing='0' class='section-columns columns-2'>
<tbody>
<tr>
<td class='first columns-cell'>
<div class='foot no-items section' id='footer-2-1'></div>
</td>
<td class='columns-cell'>
<div class='foot no-items section' id='footer-2-2'></div>
</td>
</tr>
</tbody>
</table>
<!-- outside of the include in order to lock Attribution widget -->
<div class='foot section' id='footer-3' name='Footer'><div class='widget Attribution' data-version='1' id='Attribution1'>
<div class='widget-content' style='text-align: center;'>
Simple theme. Powered by <a href='https://www.blogger.com' target='_blank'>Blogger</a>.
</div>
<div class='clear'></div>
</div></div>
</div>
</div>
<div class='footer-cap-bottom cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
</footer>
<!-- content -->
</div>
</div>
<div class='content-cap-bottom cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
</div>
<script type='text/javascript'>
    window.setTimeout(function() {
        document.body.className = document.body.className.replace('loading', '');
      }, 10);
  </script>

<script type="text/javascript" src="https://www.blogger.com/static/v1/widgets/552934507-widgets.js"></script>
<script type='text/javascript'>
window['__wavt'] = 'AOuZoY4LnrvDy4hAOfVofDAPg4Twj_K8bw:1757390326018';_WidgetManager._Init('//www.blogger.com/rearrange?blogID\x3d2363643920942057324','//blog.dscpl.com.au/2015/05/monitoring-response-content-from-wsgi.html','2363643920942057324');
_WidgetManager._SetDataContext([{'name': 'blog', 'data': {'blogId': '2363643920942057324', 'title': 'Graham Dumpleton', 'url': 'http://blog.dscpl.com.au/2015/05/monitoring-response-content-from-wsgi.html', 'canonicalUrl': 'http://blog.dscpl.com.au/2015/05/monitoring-response-content-from-wsgi.html', 'homepageUrl': 'http://blog.dscpl.com.au/', 'searchUrl': 'http://blog.dscpl.com.au/search', 'canonicalHomepageUrl': 'http://blog.dscpl.com.au/', 'blogspotFaviconUrl': 'http://blog.dscpl.com.au/favicon.ico', 'bloggerUrl': 'https://www.blogger.com', 'hasCustomDomain': true, 'httpsEnabled': false, 'enabledCommentProfileImages': true, 'gPlusViewType': 'FILTERED_POSTMOD', 'adultContent': false, 'analyticsAccountNumber': '', 'encoding': 'UTF-8', 'locale': 'en', 'localeUnderscoreDelimited': 'en', 'languageDirection': 'ltr', 'isPrivate': false, 'isMobile': false, 'isMobileRequest': false, 'mobileClass': '', 'isPrivateBlog': false, 'isDynamicViewsAvailable': true, 'feedLinks': '\x3clink rel\x3d\x22alternate\x22 type\x3d\x22application/atom+xml\x22 title\x3d\x22Graham Dumpleton - Atom\x22 href\x3d\x22http://blog.dscpl.com.au/feeds/posts/default\x22 /\x3e\n\x3clink rel\x3d\x22alternate\x22 type\x3d\x22application/rss+xml\x22 title\x3d\x22Graham Dumpleton - RSS\x22 href\x3d\x22http://blog.dscpl.com.au/feeds/posts/default?alt\x3drss\x22 /\x3e\n\x3clink rel\x3d\x22service.post\x22 type\x3d\x22application/atom+xml\x22 title\x3d\x22Graham Dumpleton - Atom\x22 href\x3d\x22https://www.blogger.com/feeds/2363643920942057324/posts/default\x22 /\x3e\n\n\x3clink rel\x3d\x22alternate\x22 type\x3d\x22application/atom+xml\x22 title\x3d\x22Graham Dumpleton - Atom\x22 href\x3d\x22http://blog.dscpl.com.au/feeds/7325859312769573665/comments/default\x22 /\x3e\n', 'meTag': '', 'adsenseClientId': 'ca-pub-6433235630058377', 'adsenseHostId': 'ca-host-pub-1556223355139109', 'adsenseHasAds': true, 'adsenseAutoAds': false, 'boqCommentIframeForm': true, 'loginRedirectParam': '', 'view': '', 'dynamicViewsCommentsSrc': '//www.blogblog.com/dynamicviews/4224c15c4e7c9321/js/comments.js', 'dynamicViewsScriptSrc': '//www.blogblog.com/dynamicviews/b4594f574ba3c273', 'plusOneApiSrc': 'https://apis.google.com/js/platform.js', 'disableGComments': true, 'interstitialAccepted': false, 'sharing': {'platforms': [{'name': 'Get link', 'key': 'link', 'shareMessage': 'Get link', 'target': ''}, {'name': 'Facebook', 'key': 'facebook', 'shareMessage': 'Share to Facebook', 'target': 'facebook'}, {'name': 'BlogThis!', 'key': 'blogThis', 'shareMessage': 'BlogThis!', 'target': 'blog'}, {'name': 'X', 'key': 'twitter', 'shareMessage': 'Share to X', 'target': 'twitter'}, {'name': 'Pinterest', 'key': 'pinterest', 'shareMessage': 'Share to Pinterest', 'target': 'pinterest'}, {'name': 'Email', 'key': 'email', 'shareMessage': 'Email', 'target': 'email'}], 'disableGooglePlus': true, 'googlePlusShareButtonWidth': 0, 'googlePlusBootstrap': '\x3cscript type\x3d\x22text/javascript\x22\x3ewindow.___gcfg \x3d {\x27lang\x27: \x27en\x27};\x3c/script\x3e'}, 'hasCustomJumpLinkMessage': false, 'jumpLinkMessage': 'Read more', 'pageType': 'item', 'postId': '7325859312769573665', 'pageName': 'Monitoring the response content from a WSGI application.', 'pageTitle': 'Graham Dumpleton: Monitoring the response content from a WSGI application.'}}, {'name': 'features', 'data': {}}, {'name': 'messages', 'data': {'edit': 'Edit', 'linkCopiedToClipboard': 'Link copied to clipboard!', 'ok': 'Ok', 'postLink': 'Post Link'}}, {'name': 'template', 'data': {'name': 'Simple', 'localizedName': 'Simple', 'isResponsive': false, 'isAlternateRendering': false, 'isCustom': false, 'variant': 'pale', 'variantId': 'pale'}}, {'name': 'view', 'data': {'classic': {'name': 'classic', 'url': '?view\x3dclassic'}, 'flipcard': {'name': 'flipcard', 'url': '?view\x3dflipcard'}, 'magazine': {'name': 'magazine', 'url': '?view\x3dmagazine'}, 'mosaic': {'name': 'mosaic', 'url': '?view\x3dmosaic'}, 'sidebar': {'name': 'sidebar', 'url': '?view\x3dsidebar'}, 'snapshot': {'name': 'snapshot', 'url': '?view\x3dsnapshot'}, 'timeslide': {'name': 'timeslide', 'url': '?view\x3dtimeslide'}, 'isMobile': false, 'title': 'Monitoring the response content from a WSGI application.', 'description': 'I have been focusing in the last couple of posts  about the overheads of generating response content from a WSGI application as many separat...', 'url': 'http://blog.dscpl.com.au/2015/05/monitoring-response-content-from-wsgi.html', 'type': 'item', 'isSingleItem': true, 'isMultipleItems': false, 'isError': false, 'isPage': false, 'isPost': true, 'isHomepage': false, 'isArchive': false, 'isLabelSearch': false, 'postId': 7325859312769573665}}]);
_WidgetManager._RegisterWidget('_NavbarView', new _WidgetInfo('Navbar1', 'navbar', document.getElementById('Navbar1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_HeaderView', new _WidgetInfo('Header1', 'header', document.getElementById('Header1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_BlogView', new _WidgetInfo('Blog1', 'main', document.getElementById('Blog1'), {'cmtInteractionsEnabled': false, 'lightboxEnabled': true, 'lightboxModuleUrl': 'https://www.blogger.com/static/v1/jsbin/3842676126-lbx.js', 'lightboxCssUrl': 'https://www.blogger.com/static/v1/v-css/828616780-lightbox_bundle.css'}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_ProfileView', new _WidgetInfo('Profile1', 'sidebar-right-1', document.getElementById('Profile1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_PageListView', new _WidgetInfo('PageList1', 'sidebar-right-1', document.getElementById('PageList1'), {'title': 'Quick Links', 'links': [{'isCurrentPage': false, 'href': 'http://blog.dscpl.com.au/p/decorators-and-monkey-patching.html', 'id': '3350721465154129789', 'title': 'Decorators and monkey patching.'}, {'isCurrentPage': false, 'href': 'http://blog.dscpl.com.au/p/using-python-with-docker.html', 'id': '5591286857776935907', 'title': 'Using Python with Docker.'}], 'mobile': false, 'showPlaceholder': true, 'hasCurrentPage': false}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_BlogArchiveView', new _WidgetInfo('BlogArchive1', 'sidebar-right-1', document.getElementById('BlogArchive1'), {'languageDirection': 'ltr', 'loadingMessage': 'Loading\x26hellip;'}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_LabelView', new _WidgetInfo('Label1', 'sidebar-right-1', document.getElementById('Label1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_AdSenseView', new _WidgetInfo('AdSense1', 'footer-1', document.getElementById('AdSense1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_AttributionView', new _WidgetInfo('Attribution1', 'footer-3', document.getElementById('Attribution1'), {}, 'displayModeFull'));
</script>
</body>
</html>