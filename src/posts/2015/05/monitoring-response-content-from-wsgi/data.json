{
  "title": "Monitoring the response content from a WSGI application.",
  "content": "I have been focusing in the last couple of [posts](/posts/2015/05/returning-string-as-iterable-from-wsgi/) about the overheads of generating response content from a WSGI application as many separate blocks rather than as one large block. This has illustrated how there can be quite marked differences between different WSGI servers and even with a specific WSGI server depending on how it is configured or integrated into an overall architecture. \n\nIn this post I want to look at how we could actually add monitoring which could track how much data is actually being returned in a response and how many blocks it was broken up into. We can also track how much time was being spent by the WSGI server trying to write that data back to the HTTP client.\n\n# Monitoring overall response time\n\nPreviously I presented a decorator which could be applied to a WSGI application to time the overall response time. That is, how long it took for the complete handling of the request, including the processing of the request content, as well as the generation of the response and the writing of it back to the HTTP client.\n\nThe code for the decorator was:\n\n```\n from __future__ import print_function\n\n from wrapt import decorator, ObjectProxy  \n from timeit import default_timer  \n   \n class WSGIApplicationIterable1(ObjectProxy):\n\n     def __init__(self, wrapped, name, start):  \n         super(WSGIApplicationIterable1, self).__init__(wrapped)  \n         self._self_name = name  \n         self._self_start = start\n\n     def close(self):  \n         if hasattr(self.__wrapped__, 'close'):  \n             self.__wrapped__.close()\n\n         duration = default_timer() - self._self_start  \n         print('finish %s %.3fms' % (self._self_name, duration*1000.0))\n\n @decorator  \n def timed_wsgi_application1(wrapped, instance, args, kwargs):  \n     name = wrapped.__name__\n\n     start = default_timer()  \n     print('start', name)\n\n     try:  \n         return WSGIApplicationIterable1(wrapped(*args, **kwargs), name, start)\n\n     except:  \n         duration = default_timer() - start  \n         print('finish %s %.3fms' % (name, duration*1000.0))  \n         raise\n```\n\nAlthough described as a decorator, this is actually implementing a form of WSGI middleware. In this case the middleware was intercepting the act of calling the WSGI application to handle the request and the finalisation of the request through the calling of any 'close\\(\\)' method of the returned iterable.\n\nWhat we didn't intercept in any way was the request content or response content. So what we want to do now is extend this to intercept the response content as it is generated so that we can count how many bytes are being generated and as how many blocks.\n\n# Intercepting the response content\n\nTo understand what is now needed to intercept the response content we need to look at how a WSGI server actually interfaces with the WSGI application. This interaction can be seen in the sample CGI to WSGI bridge presented in the [WSGI specification](https://www.python.org/dev/peps/pep-3333/#the-server-gateway-side).\n\nThe key part of the sample code presented in the WSGI specification is as follows and has three parts.\n\n```\n     result = application(environ, start_response)\n\n     try:  \n         for data in result:  \n             if data:  \n                 write(data)  \n             if not headers_sent:  \n                 write('')\n\n     finally:  \n         if hasattr(result, 'close'):  \n             result.close()\n```\n\nThe first part is the calling of the WSGI application. It is the result of this call which has been wrapped by our timing wrapper.\n\nThe result returned is then iterated over to yield each data block making up the response, with it being written back to the HTTP client.\n\nFinally, the 'close\\(\\)' method is then called on the iterable. The 'close\\(\\)' method of the iterable is called whether or not the iterable was completely consumed. The iterable may not be completely consumed if while generating any response an exception occurred, or if when writing the response back to the HTTP client an error occurred, such as the connection being dropped.\n\nIn the middleware wrapper we are so far intercepting the original WSGI application call and the call to 'close\\(\\)'.\n\nIn order to now intercept the response content we need to intercept the creation of the iterator object from the iterable when the 'in' statement is applied to it in the loop.\n\nTo do that, we need to intercept the special '\\_\\_iter\\_\\_\\(\\)' method of the iterable. As it stands right now, due to the wrapper for the iterable being implemented as a derived class of the 'ObjectProxy' class from the 'wrapt' package, the call of the '\\_\\_iter\\_\\_\\(\\)' method is being automatically applied to the original wrapped iterable. In effect the object proxy is doing:\n\n```\n     def __iter__(self):  \n         return iter(self.__wrapped__)\n```\n\nWe want to do more than simply process in some way the iterator object itself. Instead we want to process each yielded item. For this we need to iterate over the original wrapped iterable object ourselves, turning the '\\_\\_iter\\_\\_\\(\\)' method into a generator function. This can be done as:\n\n```\n     def __iter__(self):  \n         for data in self.__wrapped__:  \n             yield data\n```\n\n# The archaic write\\(\\) callback\n\nThe job of intercepting the response content seems simple enough but simply overriding '\\_\\_iter\\_\\_\\(\\)' is unfortunately not enough if you want a completely correct WSGI middleware. This is because returning an iterable is not the only way that it is possible to return response content.\n\nTo support certain older style Python web applications that preceded the WSGI specification, another way of generating response content is supported. This is via a 'write\\(\\)' callback function which is returned by the 'start\\_response\\(\\)' function when called by the WSGI application.\n\nWhen this 'write\\(\\)' callback function is used to provide the response content, then the iterable returned by the WSGI application would normally be an empty list. The code above would therefore never actually see any response content.\n\nI have blogged previously about this [hidden 'write\\(\\)' callback](/posts/2012/10/wsgi-middleware-and-hidden-write/) and although a correct WSGI middleware should support it, for the purposes of this analysis I am going to ignore it.\n\nIgnoring the 'write\\(\\)' callback function will not affect the operation of the wrapped WSGI application, but it means that if the 'write\\(\\)' callback function were used, we wouldn't report anything about the response content generated that way.\n\n# Overheads of adding monitoring\n\nNow, before we get started on adding to the basic loop for intercepting the actual response content, it is important to highlight that monitoring isn't necessarily free.\n\nIn our original timing decorator for the WSGI application we introduced a number of additional function calls, however that number was fixed for each request handled. The additional overhead from these extra calls would be acceptable so long as what those calls themselves did wasn't excessive.\n\nWhen we start talking about intercepting the request content so as to accumulate metric information about the data being generated for the response, we would be adding extra calls and processing for every distinct data block.\n\nWe have already seen how an excessive number of distinct data blocks in a worst case scenario can be a problem with some WSGI servers. We therefore have to be very careful, as although the additional overhead of the monitoring code may not present a problem when there are a small number of data blocks, the extra work being performed could exacerbate the worst case scenario and severely affect the responsiveness of the monitored application at the one time the server is already stressed and so when you don't want that to occur.\n\nIdeally the generation of metric information about a request would be embedded within the WSGI server itself so as to avoid the need to add in special wrappers which add to the number of intermediate calls being made. Unfortunately the majority of WSGI servers provide no such functionality. The next best alternative is to consider writing any such monitoring wrappers as a Python C extension to limit the potential overhead.\n\nHowever monitoring is added, one key thing to try and always avoid is doing too much processing during the life of the request itself. Any extra processing that is done during the request will obviously add to the response time as seen by the user. Thus you should try and do the absolute minimum while the request is being handled and try to defer more complex processing based on any raw data collected, until after the request has completed.\n\nBy doing this the impact on the response time is at least reduced, albeit that it still potentially comes at a cost. This extra cost may be in extra memory usage due to needing to hold raw data for processing at the end of the request, but also in additional CPU usage from doing that processing.\n\nDeferring complex processing until the end of the request will also still keep that request thread busy until it is complete, preventing it from being released to handle a subsequent request, be that a request on a totally distinct connection or a request on a keep alive connection. This delayed release of the request thread can therefore potentially cause a reduction in available server capacity.\n\nOverall, monitoring is a bit of a balancing act. You can't avoid all overheads from monitoring and so when monitoring is first added you may see a reduction in performance as a result. The visibility one gets from adding monitoring though allows you to more easily identify potential issues and fix them. You therefore quite quickly get to a better point than where you were originally without monitoring and so the hit you take from the monitoring is worth it.\n\nYou could well at this point remove the monitoring and so eliminate the overheads once more, but you would then be running in the dark again and so have no idea when you introduce some bad code once more. Best to accept the initial overheads and just get on with improving your code from what you learn. Just be careful in designing the monitoring code to reduce the overheads as much as possible.\n\nThat all said, let's try and continue by calculating a baseline to gauge how much overhead any monitoring may be adding. For that we can first try to use our prior test example whereby we returned a large string as the iterable.\n\n```\n from timer1 import timed_wsgi_application1\n\n @timed_wsgi_application1  \n def application(environ, start_response):  \n     status = '200 OK'  \n     output = 100000 * b'Hello World!'\n\n    response_headers = [('Content-type', 'text/plain'),  \n        ('Content-Length', str(len(output)))]  \n     start_response(status, response_headers)\n\n    return output\n```\n\nWith our original decorator which measures just the length of time spent in the WSGI application, when we use mod\\_wsgi-express this time we get:\n\n```\n start application  \n finish application 6269.062ms\n```\n\nIf we override the '\\_\\_iter\\_\\_\\(\\)' method to introduce the loop but not do any processing:\n\n```\n     def __iter__(self):  \n         for data in self.__wrapped__:  \n             yield data\n```\n\nwe now get:\n\n```\n start application  \n finish application 6291.978ms\n```\n\nNot much difference, but a further big warning has to be made.\n\nThe problem with making minor changes like this and triggering one off test runs is that it is actually really hard to truly gauge the impact of the change, especially in a case like this where one was already stressing the WSGI server quite severely, with CPU usage peaking up towards 100%.\n\nThis is because when a system is being stressed to the maximum, the variability between the results from one run to the next can be quite marked and so when there isn't much difference the results for the two variations on the code can actually overlap as the result values bounce around.\n\nAlthough the normal approach to eliminating such variability is to run the benchmark test many many times and try and determine some sort of average, or at least eliminate outliers, this doesn't generally help in a situation where the WSGI server is being stressed to breaking point.\n\nThis is actually one of the big mistakes people make when trying to benchmark WSGI servers to try and work out which may be able to handle the greatest throughput. That is, they just flood the WSGI servers with requests such that they are overloaded, which only serves to generate results which are quite unpredictable.\n\nWhen trying to evaluate WSGI server performance it is better to evaluate how it behaves at a level of about 50% capacity utilisation. This is a level whereby you aren't triggering pathological cases of performance degradation through overloading, yet still gives you some measure of head room for transient peaks in the request throughput.\n\nIf you are constantly pushing high levels of capacity utilisation in a WSGI server then you should really be looking at scaling out horizontally to ensure you have the spare capacity to meet demands as they arise, rather than running the WSGI server at breaking point.\n\nSo trying to gauge overheads at this point is partly a pointless exercise with the test we have, so lets just get on with implementing the code instead and we will revisit the issue of measuring overhead later.\n\n# Counting writes and bytes\n\nThe initial change we were therefore after was tracking how much data is actually being returned in a response and how many blocks it was broken up into. Overriding the '\\_\\_iter\\_\\_\\(\\)' method we can do this using:\n\n```\n class WSGIApplicationIterable2(ObjectProxy):\n\n     def __init__(self, wrapped, name, start):  \n         super(WSGIApplicationIterable2, self).__init__(wrapped)  \n         self._self_name = name  \n         self._self_start = start  \n         self._self_count = 0  \n         self._self_bytes = 0\n\n     def __iter__(self):  \n         count = 0  \n         bytes = 0  \n         try:  \n             for data in self.__wrapped__:  \n                 yield data  \n                 count += 1  \n                 bytes += len(data)  \n         finally:  \n             self._self_count = count  \n             self._self_bytes = bytes\n\n     def close(self):  \n         if hasattr(self.__wrapped__, 'close'):  \n             self.__wrapped__.close()\n\n         duration = default_timer() - self._self_start  \n         print('write %s blocks %s bytes' % (self._self_count, self._self_bytes))  \n         print('finish %s %.3fms' % (self._self_name, duration*1000.0))\n```\n\nRun this with our test example where a string was returned as the iterable rather than a list of strings, we get:\n\n```\n start application  \n write 1200000 blocks 1200000 bytes  \n finish application 5499.676ms\n```\n\nThis is in contrast to what we would hope to see, which is a small as possible number of blocks, and even just the one block if that was achievable without blowing out memory usage.\n\n```\n start application  \n write 1 blocks 1200000 bytes  \n finish application 4.867ms\n```\n\nWhat we are obviously hoping for here is a low number of blocks, or at least a high average number of bytes per block. If the average number of bytes per block is very low, then it would be worthy of further inspection.\n\n# Time taken to write output\n\nTracking the number of bytes written and the number of blocks can highlight potential issues, but it doesn't actually tell us how long was spent writing the data back to the HTTP client. Knowing the time taken will help us confirm whether the response being returned as a large number of blocks is an issue or not. To capture information about the amount of time taken we can use:\n\n```\n class WSGIApplicationIterable3(ObjectProxy):\n\n     def __init__(self, wrapped, name, start):  \n         super(WSGIApplicationIterable3, self).__init__(wrapped)  \n         self._self_name = name  \n         self._self_start = start  \n         self._self_time = 0.0  \n         self._self_count = 0  \n         self._self_bytes = 0\n\n     def __iter__(self):  \n         time = 0.0  \n         start = 0.0  \n         count = 0  \n         bytes = 0  \n         try:  \n             for data in self.__wrapped__:  \n                 start = default_timer()  \n                 yield data  \n                 finish = default_timer()   \n                 if finish > start:  \n                     time += (finish - start)  \n                 start = 0.0  \n                 count += 1  \n                 bytes += len(data)  \n         finally:  \n             if start:  \n                 finish = default_timer()  \n                 if finish > start:  \n                     time += (finish - start)\n\n         self._self_time = time  \n         self._self_count = count  \n         self._self_bytes = bytes\n\n     def close(self):  \n         if hasattr(self.__wrapped__, 'close'):  \n               self.__wrapped__.close()\n\n         duration = default_timer() - self._self_start  \n         print('write %s blocks %s bytes %.3fms' % (self._self_count,  \n                 self._self_bytes, self._self_time*1000.0))  \n         print('finish %s %.3fms' % (self._self_name, duration*1000.0))\n```\n\nIn this version of the wrapper we time how long it took to yield each value from the loop. This has the affect of timing how long it took any outer layer, in this case how long the WSGI server took, to process and write the block of data back to the HTTP client.\n\nRunning our test example now we get:\n\n```\n start application  \n write 1200000 blocks 1200000 bytes 6654.018ms  \n finish application 7812.504ms\n```\n\nWe can therefore see that the time taken in writing out the actual data took a large proportion of the overall response time. In this case the actual test example wasn't itself doing much work so that would have been the case anyway, but the magnitude of the amount of time spent writing the response in conjunction with the number of blocks is the concern.\n\nDo though keep in mind that even if you were writing as few blocks as possible that if a large amount of data was involved, that the WSGI server could itself block when writing to the socket if the HTTP client wasn't reading the data quickly enough.\n\nThe time taken can therefore be helpful in pointing out other issues as well and not just the cumulative impact of writing many small blocks of data.\n\nThe big question now is how you turn such information into actionable data.\n\nUsing print statements to output timing values is all well and good in a test scenario when playing around with WSGI servers, but it isn't of any use in a production environment. The next step therefore is to look at how one can capture such information in bulk in the context of a production environment and whether it still remains useful at that point.",
  "date": "2015-05-23",
  "author": "Graham Dumpleton",
  "url": "http://blog.dscpl.com.au/2015/05/monitoring-response-content-from-wsgi.html",
  "post_id": "7325859312769573665",
  "blog_id": "2363643920942057324",
  "comments": [],
  "labels": [
    "python",
    "wsgi"
  ],
  "metadata": {
    "published_timestamp": "2015-05-23T21:41:00+10:00",
    "blog_title": "Graham Dumpleton",
    "page_title": "Graham Dumpleton: Monitoring the response content from a WSGI application.",
    "og_title": "Monitoring the response content from a WSGI application.",
    "og_description": "I have been focusing in the last couple of posts  about the overheads of generating response content from a WSGI application as many separat...",
    "og_url": "http://blog.dscpl.com.au/2015/05/monitoring-response-content-from-wsgi.html"
  },
  "downloaded_images": []
}