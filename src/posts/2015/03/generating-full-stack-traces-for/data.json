{
  "title": "Generating full stack traces for exceptions in Python.",
  "content": "My last few blog posts have been about monkey patching. I will be continuing with more posts on that topic, but I am going to take a slight detour away from that topic in this post to talk about a problem related to capturing stack trace information for exceptions in Python applications.\n\nThis does still have some relevance to monkey patching, in as much as one of the reasons you may want to monkey patch a Python application is to add in wrappers which will intercept the the details of an exception raised deep with an application. You might want to do this for the case where the exception would otherwise be captured by an application and translated into a different exception, with loss of information about the inner exception, or in the case of a web application result in a generic HTTP 500 web page response with no useful information captured. So monkey patching can be a useful debugging tool where it may not be convenient to modify the original source code of the application.\n\n# Tracebacks for exceptions\n\nTo get started, lets consider the following Python script:\n\n```\n def function1():  \n     raise RuntimeError('xxx')\n \n \n def function2():  \n     function1()\n \n \n def function3():  \n     function2()\n \n \n def function4():  \n     function3()\n \n \n def function5():  \n     function4()\n \n \n function5()\n```\n\nIf we run this script we will get:\n\n```\n Traceback (most recent call last):  \n   File \"generate-1.py\", line 16, in <module>  \n     function5()  \n   File \"generate-1.py\", line 14, in function5  \n     function4()  \n   File \"generate-1.py\", line 11, in function4  \n     function3()  \n   File \"generate-1.py\", line 8, in function3  \n     function2()  \n   File \"generate-1.py\", line 5, in function2  \n     function1()  \n   File \"generate-1.py\", line 2, in function1  \n     raise RuntimeError('xxx')  \n RuntimeError: xxx\n```\n\nIn this case we have an exception occurring which was never actually caught within the script itself and is propagated all the way up to the top level, causing the script to be terminated and the traceback printed.\n\nWhen the traceback was printed, it showed all stack frames from the top level all the way down to the point where the exception occurred.\n\nNow consider the Python script:\n\n```\n import traceback\n \n \n def function1():  \n     raise RuntimeError('xxx')\n \n \n def function2():  \n     function1()\n \n \n def function3():  \n     try:  \n       function2()  \n     except Exception:  \n       traceback.print_exc()\n \n \n def function4():  \n     function3()\n \n \n def function5():  \n     function4()\n \n \n function5()\n```\n\nIn this script we have a 'try/except' block half way down the sequence of calls. The call to 'function2\\(\\)' is made within the 'try' block and when the exception is raised, it is handled within the 'except' block. At that point we use the 'traceback.print\\_exc\\(\\)' function to output the details of the exception, but then let the script continue on normally to completion.\n\nFor this Python script the output is:\n\n```\n Traceback (most recent call last):  \n   File \"generate-2.py\", line 11, in function3  \n     function2()  \n   File \"generate-2.py\", line 7, in function2  \n     function1()  \n   File \"generate-2.py\", line 4, in function1  \n     raise RuntimeError('xxx')  \n RuntimeError: xxx\n```\n\nWhat you see here though is that we loose information about the outer stack frames for the sequence of calls that led down to the point where the 'try/except' block existed.\n\nWhen we want to capture details of an exception for logging purposes so as to later debug an issue, this loss of information can make it harder to debug a problem if the function containing the 'try/except' block could be called from multiple places.\n\nHow then can we capture the outer stack frames so we have that additional context?\n\n# Capturing the current stack\n\nThere are a number of ways of obtaining information about the current stack. If we are just wanting to dump out the current stack to a log then we can use 'traceback.print\\_stack\\(\\)'.\n\n```\n import traceback\n \n \n def function1():  \n     raise RuntimeError('xxx')\n \n \n def function2():  \n     function1()\n \n \n def function3():  \n     try:  \n         function2()  \n     except Exception:  \n         traceback.print_stack()  \n         print '--------------'  \n         traceback.print_exc()\n \n \n def function4():  \n     function3()\n \n \n def function5():  \n     function4()\n \n \n function5()\n```\n\nRun this variant of the Python script and we now get:\n\n```\n   File \"generate-3.py\", line 23, in <module>  \n     function5()  \n   File \"generate-3.py\", line 21, in function5  \n     function4()  \n   File \"generate-3.py\", line 18, in function4  \n     function3()  \n   File \"generate-3.py\", line 13, in function3  \n     traceback.print_stack()  \n --------------  \n Traceback (most recent call last):  \n   File \"generate-3.py\", line 11, in function3  \n     function2()  \n   File \"generate-3.py\", line 7, in function2  \n     function1()  \n   File \"generate-3.py\", line 4, in function1  \n     raise RuntimeError('xxx')  \n RuntimeError: xxx\n```\n\nSo we now have the inner stack frames corresponding to the exception traceback, as well as those outer stack frames corresponding to the current stack. From this we can presumably now join these two sets of stack frames together and get a complete stack trace for where the exception occurred.\n\nIf you look closely though you may notice something. That is that there is actually an overlap in the stack frames which are shown for each, plus that the function we have called to print the current stack is also shown.\n\nIn the case of the overlap the issue is that in the inner stack frames from the traceback, it shows an execution point in 'function3\\(\\)' of line 11. This corresponds to the point where 'function2\\(\\)' was called within the 'try' block and in which the exception occurred.\n\nAt the same time, the outer stack frames from the current execution stack show line 13 in 'function3\\(\\)', which is the point within the 'except' block where we called 'traceback.print\\_stack\\(\\)' to display the current stack.\n\nSo the top most stack frame from the traceback is actually want we want and we need to ignore the bottom most two stack frames from the current stack if we were to join these together.\n\nNow although the output of these two functions can be directed to any file like object and thus an instance of 'StringIO' could be used to capture the output, we would still need to break apart the formatted text output, drop certain parts and rearrange others to get the final desired result.\n\nDealing with such pre formatted output could therefore be a pain, especially if what we really wanted was the raw information about the filename, line number, function and potentially the code snippet. What other options therefore exist for getting such raw information?\n\n# Using the inspect module\n\nWhen needing to perform introspection or otherwise derive information about Python objects, the module you want to use is the 'inspect' module. For the case of getting information about the current exception and current stack, the two functions you can use are 'inspect.trace\\(\\)' and 'inspect.stack\\(\\)'. Using these we can rewrite our Python script as:\n\n```\n import inspect\n \n \n def function1():  \n     raise RuntimeError('xxx')\n \n \n def function2():  \n     function1()\n \n \n def function3():  \n     try:  \n         function2()  \n     except Exception:  \n         for item in reversed(inspect.stack()):  \n             print item[1:]  \n         print '--------------'  \n         for item in inspect.trace():  \n             print item[1:]\n \n \n def function4():  \n     function3()\n \n \n def function5():  \n     function4()\n \n \n function5()\n```\n\nThis time we get:\n    \n    \n    ('generate-4.py', 25, '<module>', ['function5()\\n'], 0)  \n    ('generate-4.py', 23, 'function5', [' function4()\\n'], 0)  \n    ('generate-4.py', 20, 'function4', [' function3()\\n'], 0)  \n    ('generate-4.py', 13, 'function3', [' for item in reversed(inspect.stack()):\\n'], 0)  \n    --------------  \n    ('generate-4.py', 11, 'function3', [' function2()\\n'], 0)  \n    ('generate-4.py', 7, 'function2', [' function1()\\n'], 0)  \n    ('generate-4.py', 4, 'function1', [\" raise RuntimeError('xxx')\\n\"], 0)\n\nSo these functions provide us with the raw information rather than pre formatted text, thus making it easier to process. For each stack frame we also get a reference to the frame object itself, but since we didn't care about that we skipped it when displaying each frame.\n\nBecause though we might want to generate such a combined stack trace in multiple places we obviously separate this out into a function of its own.\n\n```\n import inspect\n \n \n def print_full_stack():  \n     print 'Traceback (most recent call last):'  \n     for item in reversed(inspect.stack()[2:]):  \n         print ' File \"{1}\", line {2}, in {3}\\n'.format(*item),  \n     for line in item[4]:  \n         print ' ' + line.lstrip(),  \n     for item in inspect.trace():  \n         print ' File \"{1}\", line {2}, in {3}\\n'.format(*item),  \n     for line in item[4]:  \n         print ' ' + line.lstrip(),\n \n \n def function1():  \n     raise RuntimeError('xxx')\n \n \n def function2():  \n     function1()\n \n \n def function3():  \n     try:  \n         function2()  \n     except Exception:  \n         print_full_stack()\n \n \n def function4():  \n     function3()\n \n \n def function5():  \n     function4()\n \n \n function5()\n```\n\nThe final result would now be:\n\n```\n Traceback (most recent call last):  \n   File \"generate-5.py\", line 32, in <module>  \n     function5()  \n   File \"generate-5.py\", line 30, in function5  \n     function4()  \n   File \"generate-5.py\", line 27, in function4  \n     function3()  \n   File \"generate-5.py\", line 22, in function3  \n     function2()  \n   File \"generate-5.py\", line 18, in function2  \n     function1()  \n   File \"generate-5.py\", line 15, in function1  \n     raise RuntimeError('xxx')\n```\n\n# Using the exception traceback\n\nWe are done right? No.\n\nIn this case we have relied on functions from the 'inspect' module that rely on being called directly from within the 'except' block.\n\nThat is, for generating the outer stack frames for the current stack we always assume that we need to drop two stack frames from the result of calling 'inspect.stack\\(\\)'.\n\nFor the inner stack frames from the exception, the 'inspect.trace\\(\\)' function relies on there being an exception which is currently being handled.\n\nThat we are assuming we should skip two stack frames for the current stack is a little bit fragile. For example, consider the case where we don't actually call 'print\\_full\\_stack\\(\\)' within the 'except' block itself.\n\n```\n def function1():  \n     raise RuntimeError('xxx')\n \n \n def function2():  \n     function1()\n \n \n def function3a():  \n     print_full_stack()\n \n \n def function3():  \n     try:  \n         function2()  \n     except Exception:  \n         function3a()\n \n \n def function4():  \n     function3()\n \n \n def function5():  \n     function4()\n \n \n function5()\n```\n\nThe result here is:\n\n```\n Traceback (most recent call last):  \n   File \"generate-6.py\", line 35, in <module>  \n     function5()  \n   File \"generate-6.py\", line 33, in function5  \n     function4()  \n   File \"generate-6.py\", line 30, in function4  \n     function3()  \n   File \"generate-6.py\", line 27, in function3  \n     function3a()  \n   File \"generate-6.py\", line 25, in function3  \n     function2()  \n   File \"generate-6.py\", line 18, in function2  \n     function1()  \n   File \"generate-6.py\", line 15, in function1  \n     raise RuntimeError('xxx')\n```\n\nAs can be seen, we actually end up with an additional stack frame being inserted corresponding to 'function3a\\(\\)' which we called within the 'except' block and which in turn called 'print\\_full\\_stack\\(\\)'.\n\nTo ensure we do the right thing here we need to look at what 'inspect.stack\\(\\)' and 'inspect.trace\\(\\)' actually do.\n\n```\n def stack(context=1):  \n     \"\"\"Return a list of records for the stack above the caller's frame.\"\"\"  \n     return getouterframes(sys._getframe(1), context)\n \n \n def trace(context=1):  \n     \"\"\"Return a list of records for the stack below the current exception.\"\"\"  \n     return getinnerframes(sys.exc_info()[2], context)\n```\n\nSo the problem we have with the extra stack frame is that 'inspect.stack\\(\\)' uses 'sys.\\_getframe\\(\\)' to grab the current stack. This is correct and what it is intended to do, but not really what we want. What we instead want is the outer stack frames corresponding to where the exception was caught.\n\nAs it turns out this is available as an attribute on the traceback object for the exception called 'tb\\_frame'. Learning from how these two functions are implemented, we can therefore change our function to print the full stack.\n\n```\n import sys  \n import inspect\n \n \n def print_full_stack(tb=None):  \n     if tb is None:  \n         tb = sys.exc_info()[2]\n \n \n     print 'Traceback (most recent call last):'  \n     for item in reversed(inspect.getouterframes(tb.tb_frame)[1:]):  \n         print ' File \"{1}\", line {2}, in {3}\\n'.format(*item),  \n         for line in item[4]:  \n             print ' ' + line.lstrip(),  \n         for item in inspect.getinnerframes(tb):  \n             print ' File \"{1}\", line {2}, in {3}\\n'.format(*item),  \n         for line in item[4]:  \n             print ' ' + line.lstrip(),\n \n \n def function1():  \n     raise RuntimeError('xxx')\n \n \n def function2():  \n     function1()\n \n \n def function3a():  \n     print_full_stack()\n \n \n def function3():  \n     try:  \n         function2()  \n     except Exception:  \n         function3a()\n \n \n def function4():  \n     function3()\n \n \n def function5():  \n     function4()\n \n \n function5()\n```\n\nWe are now back to the desired result we are after.\n\n```\n Traceback (most recent call last):  \n   File \"generate-7.py\", line 39, in <module>  \n     function5()  \n   File \"generate-7.py\", line 37, in function5  \n     function4()  \n   File \"generate-7.py\", line 34, in function4  \n     function3()  \n   File \"generate-7.py\", line 29, in function3  \n     function2()  \n   File \"generate-7.py\", line 22, in function2  \n     function1()  \n   File \"generate-7.py\", line 19, in function1  \n     raise RuntimeError('xxx')\n```\n\n# Using a saved traceback\n\nIn making this last modification we actually implemented 'print\\_full\\_stack\\(\\)' to optionally accept an existing traceback. If none was supplied then we would instead use the traceback for the current exception being handled.\n\nIt is likely a rare situation where it would be required, but this allows one to pass in a traceback object which had been saved away and retained beyond the life of the 'try/except' block which generated it.\n\nBe aware though that doing this can generate some surprising results.\n\n```\n def function1():  \n     raise RuntimeError('xxx')\n \n \n def function2():  \n     function1()\n \n \n def function3():  \n     try:  \n         function2()  \n     except Exception:  \n         return sys.exc_info()[2]\n \n \n def function4():  \n      tb = function3()  \n      print_full_stack(tb)\n \n \n def function5():  \n      function4()\n \n \n function5()\n```\n\nIn this case we return the traceback to an outer scope and only within that outer function attempt to print out the full stack for the exception.\n\n```\n Traceback (most recent call last):  \n   File \"generate-8.py\", line 37, in <module>  \n     function5()  \n   File \"generate-8.py\", line 35, in function5  \n     function4()  \n   File \"generate-8.py\", line 32, in function4  \n     print_full_stack(tb)  \n   File \"generate-8.py\", line 26, in function3  \n     function2()  \n   File \"generate-8.py\", line 22, in function2  \n     function1()  \n   File \"generate-8.py\", line 19, in function1  \n     raise RuntimeError('xxx')\n```\n\nThe problem here is that in 'function4\\(\\)' rather than seeing the line where the call to 'function3\\(\\)' was made, we see where the call to 'print\\_full\\_stack\\(\\)' is made.\n\nThe reason for this is that although the traceback contains a snapshot of information from the current stack at the time of the exception, this only extends back as far as the 'try/except' block.\n\nWhen we are accessing 'tb.tb\\_frame' and getting the outer frames, it is still accessing potentially active stack frames for any currently executing code.\n\nSo what has happened is that in looking at the stack frame for 'function4\\(\\)' it is picking up the current execution line number at that point in time, which has shifted from the time when the original exception occurred. That is, control returned back into 'function4\\(\\)' and execution progressed to the next line and the call 'print\\_full\\_stack\\(\\)'.\n\nAlthough the ability to print the full stack trace for the exception is useful, it is only reliable if called within the same function that the 'try/except' block existed. If you return the traceback object to an outer function and then try and produce the full stack, line number information in the outer stack frames can be wrong, due to the code execution point within those functions shifting if subsequent code in those functions had been executed since the exception occurred.\n\nIf anyone knows a way around this, beyond creating a snapshot of the full stack within the same function as where the 'try/except' occurred, I would be interested to hear how. My current understanding is that there isn't any way and it is just a limitation one has to live with in that case.",
  "date": "2015-03-21",
  "author": "Graham Dumpleton",
  "url": "http://blog.dscpl.com.au/2015/03/generating-full-stack-traces-for.html",
  "post_id": "7672746776551574219",
  "blog_id": "2363643920942057324",
  "comments": [
    {
      "comment_id": "3250530999419655111",
      "author": "Deron Meranda",
      "author_url": "https://www.blogger.com/profile/18332381064910373026",
      "author_profile_id": "18332381064910373026",
      "content": "Also, what about Python 3's Exception Chaining \\(PEP 3134\\)?  \n  \nI have a library that provides hooks via user-supplied callbacks; and if the callback raises an exception, it gets repackaged in my own exception type with a chain to the original exception. To allow the library to work in both Python 2 and 3 \\(even with 2to3\\) I manually construct the chain, such as this in Python 2 syntax:  \n  \ntry:  \ncall\\_callback\\(\\)  \nexcept Exception, err:  \ne2 = sys.exc\\_info\\(\\)  \nnewerr = MyException\\( ..stuff.. \\)  \nnewerr.\\_\\_cause\\_\\_ = err  \nnewerr.\\_\\_traceback\\_\\_ = e2\\[2\\]  \nraise newerr  \n  \nIs this a good method, or am I loosing information?",
      "timestamp": "March 22, 2015 at 3:49 AM",
      "permalink": "http://blog.dscpl.com.au/2015/03/generating-full-stack-traces-for.html?showComment=1426956591144#c3250530999419655111",
      "is_blog_author": false
    },
    {
      "comment_id": "8228269230229987543",
      "author": "Graham Dumpleton",
      "author_url": "https://www.blogger.com/profile/13609779138164842374",
      "author_profile_id": "13609779138164842374",
      "content": "With chaining of exceptions, because the traceback of initial exceptions would be retained beyond the life of the try/except for those when re-raising a different exception, I would imaging the issue described with line numbers not then being accurate for the outer stack frames would apply.",
      "timestamp": "March 23, 2015 at 9:55 AM",
      "permalink": "http://blog.dscpl.com.au/2015/03/generating-full-stack-traces-for.html?showComment=1427064909483#c8228269230229987543",
      "is_blog_author": true
    },
    {
      "comment_id": "1179415365958851471",
      "author": "Piotr Dobrogost",
      "author_url": "https://www.blogger.com/profile/09529158749729184143",
      "author_profile_id": "09529158749729184143",
      "content": "It seems _creating a snapshot of the full stack within the same function as where the 'try/except' occurred_ is really the only way to provide full context of exception. The question is why Python itself does not do this and attach this snapshot to exception? I guess this might be to avoid cost of taking snapshot. If this is the case then Python should provide hook called every time a catch clause is entered. Related is http://stackoverflow.com/questions/1029318/calling-a-hook-function-every-time-an-exception-is-raised. I encourage you to take this problem to python-ideas to see if there's a chance of improving this aspect of language. Stack trace is crucial information and Python should really provide easy way to get it.  \n  \nI'm also wondering if \\(contrary to Alex Martelli's statement in above SO thread\\) you found a way to monkey patch Python itself, obtaining missing hook I described above as result...",
      "timestamp": "March 26, 2015 at 9:30 PM",
      "permalink": "http://blog.dscpl.com.au/2015/03/generating-full-stack-traces-for.html?showComment=1427365838950#c1179415365958851471",
      "is_blog_author": false
    },
    {
      "comment_id": "2792610626743454134",
      "author": "Graham Dumpleton",
      "author_url": "https://www.blogger.com/profile/13609779138164842374",
      "author_profile_id": "13609779138164842374",
      "content": "No, there is no one way of being able to patch Python at that level without changing the C code of the interpreter itself.",
      "timestamp": "March 26, 2015 at 9:45 PM",
      "permalink": "http://blog.dscpl.com.au/2015/03/generating-full-stack-traces-for.html?showComment=1427366740408#c2792610626743454134",
      "is_blog_author": true
    },
    {
      "comment_id": "1722273257065501315",
      "author": "Piotr Dobrogost",
      "author_url": "https://www.blogger.com/profile/09529158749729184143",
      "author_profile_id": "09529158749729184143",
      "content": "And what do you think about idea of Python provided hook called upon entering except/finally block?",
      "timestamp": "March 27, 2015 at 2:10 AM",
      "permalink": "http://blog.dscpl.com.au/2015/03/generating-full-stack-traces-for.html?showComment=1427382645483#c1722273257065501315",
      "is_blog_author": false
    },
    {
      "comment_id": "8307351316519777926",
      "author": "Graham Dumpleton",
      "author_url": "https://www.blogger.com/profile/13609779138164842374",
      "author_profile_id": "13609779138164842374",
      "content": "One could possibly argue the case for a sys.setexcept\\(\\)/sys.getexpect\\(\\) hooking mechanism in the same vain as those for profile and trace call backs, but would want to see the good use case for it.  \n  \nA problem noted on SO is how you distinguish an internal implementation detail where the exception is caught and suppressed automatically such as StopIteration, AttributeError on getattr\\(\\) failure etc etc.  \n  \nHaving a callback could easily lead to making it easy for users to cause problems if used poorly, but then that situation exists with the profile and trace hooks now.  \n  \nSo am not fore or against.",
      "timestamp": "March 27, 2015 at 11:52 AM",
      "permalink": "http://blog.dscpl.com.au/2015/03/generating-full-stack-traces-for.html?showComment=1427417550168#c8307351316519777926",
      "is_blog_author": true
    },
    {
      "comment_id": "221806409423818641",
      "author": "guettli",
      "author_url": "https://www.blogger.com/profile/00266664518110871670",
      "author_profile_id": "00266664518110871670",
      "content": "I wanted to see the upper frames some months ago. The issue I created was solved in Python3. I never tried the solution since I am still fixed on Python2. Issue: https://bugs.python.org/issue9427",
      "timestamp": "June 5, 2015 at 4:30 PM",
      "permalink": "http://blog.dscpl.com.au/2015/03/generating-full-stack-traces-for.html?showComment=1433485829841#c221806409423818641",
      "is_blog_author": false
    },
    {
      "comment_id": "7148103652676574126",
      "author": null,
      "author_url": null,
      "author_profile_id": null,
      "content": "I had the same problem last day, but worse because of threading  \n  \nHere my solution:  \n  \ndef get\\_stack\\(skip=1, tb=None\\):  \nstack = traceback.extract\\_stack\\(\\)\\[:-\\(1+skip\\)\\]  \n  \n\\# if we are in a properly created thread, preprend the thread stack  \nif hasattr\\(threading.current\\_thread\\(\\), \"\\_stack\"\\):  \nstack = getattr\\(threading.current\\_thread\\(\\), \"\\_stack\"\\) + stack  \n  \n\\# Remove threading init calls  \nthreading\\_lib\\_path = threading.\\_\\_file\\_\\_.rstrip\\(\"c\"\\)  \nstack = filter\\(lambda x : x\\[0\\] \\!= threading\\_lib\\_path, stack\\)  \n  \nif tb:  \nstack += tb  \nelse:  \n\\# complete stack with the real exception launcher if exists  \nerr\\_tb = sys.exc\\_info\\(\\)\\[2\\]  \nif err\\_tb is not None:  \nstack += traceback.extract\\_tb\\(err\\_tb\\)  \ndel err\\_tb  \n  \n\\#return result  \nreturn stack  \n  \ndef create\\_thread\\(\\*args, \\*\\*kwargs\\):  \nthread = threading.Thread\\(\\*args, \\*\\*kwargs\\)  \nsetattr\\(thread, \"\\_stack\", get\\_stack\\(\\)\\)  \nreturn thread  \n  \n  \nIt's far from perfect, but I don't know make better  \nI hope it can help someone",
      "timestamp": "February 3, 2017 at 1:22 PM",
      "permalink": "http://blog.dscpl.com.au/2015/03/generating-full-stack-traces-for.html?showComment=1486088545689#c7148103652676574126",
      "is_blog_author": false
    },
    {
      "comment_id": "5212138471780742479",
      "author": "Delgan",
      "author_url": "https://www.blogger.com/profile/01879066589943384553",
      "author_profile_id": "01879066589943384553",
      "content": "Hi, thanks for this article which helped me to better understand how traceback, stacks and exceptions work in Python.  \n  \nOne possible and elegant solution to the problem is to walk back trough the stack and create fake tracebacks which could be preprended to the actual traceback got from \"sys.exc\\_info\". That way, the traceback starts from the root and continues to the error fluently.  \n  \nThis is described in this StackOverflow answer: https://stackoverflow.com/a/13210518/2291710  \n  \nI actually implemented it before I saw the SO question, it looked like this:  \n  \n_  \nclass fake\\_traceback:  \n  \ndef \\_\\_init\\_\\_\\(self, frame, lasti, lineno, next\\_=None\\):  \nself.tb\\_frame = frame  \nself.tb\\_lasti = lasti  \nself.tb\\_lineno = lineno  \nself.tb\\_next = next\\_  \n  \ndef function3\\(\\):  \ntry:  \nfunction2\\(\\)  \nexcept:  \netype, ex, tb = sys.exc\\_info\\(\\)  \ntb = fake\\_traceback\\(tb.tb\\_frame, tb.tb\\_lasti, tb.tb\\_lineno, tb.tb\\_next\\)  \nframe = tb.tb\\_frame.f\\_back  \nwhile frame:  \ntb = fake\\_traceback\\(frame, frame.f\\_lasti, frame.f\\_lineno, tb\\)  \nframe = frame.f\\_back  \n  \nprint\\(''.join\\(traceback.format\\_tb\\(tb\\)\\)\\)  \n_",
      "timestamp": "November 1, 2017 at 12:50 AM",
      "permalink": "http://blog.dscpl.com.au/2015/03/generating-full-stack-traces-for.html?showComment=1509457827102#c5212138471780742479",
      "is_blog_author": false
    },
    {
      "comment_id": "5144835884908107248",
      "author": "Michael Herrmann",
      "author_url": "https://www.blogger.com/profile/04833014792035469716",
      "author_profile_id": "04833014792035469716",
      "content": "I encountered this problem while developing a GUI app with PyQt. For other people with the same setup, I wrote a [blog post](https://fman.io/blog/pyqt-excepthook/) with a solution mirroring the one by Adrien above. Maybe it will spare someone the hours I just spent\\!",
      "timestamp": "March 30, 2018 at 3:51 AM",
      "permalink": "http://blog.dscpl.com.au/2015/03/generating-full-stack-traces-for.html?showComment=1522342269537#c5144835884908107248",
      "is_blog_author": false
    }
  ],
  "labels": [
    "python"
  ],
  "metadata": {
    "published_timestamp": "2015-03-21T23:36:00+11:00",
    "blog_title": "Graham Dumpleton",
    "page_title": "Graham Dumpleton: Generating full stack traces for exceptions in Python.",
    "og_title": "Generating full stack traces for exceptions in Python.",
    "og_description": "My last few blog posts have been about monkey patching. I will be continuing with more posts on that topic, but I am going to take a slight ...",
    "og_url": "http://blog.dscpl.com.au/2015/03/generating-full-stack-traces-for.html"
  },
  "downloaded_images": []
}