{
  "title": "Obligations for calling close() on the iterable returned by a WSGI application.",
  "content": "Despite the [WSGI](http://www.python.org/dev/peps/pep-3333/) specification having been around for so long, one keeps seeing instances where it is implemented wrongly. At [New Relic](http://newrelic.com/) where I work on the Python agent, we have been caught by this a number of times. The problem is that if people don't implement a WSGI server or WSGI middleware per the requirements of the specification, our Python agent for web application performance monitoring will not always work as intended.  \n  \nThis is especially the case in relation to the obligations of a WSGI server or WSGI middleware to call the close\\(\\) method, if it exists, on the iterable object returned by the WSGI application. This caused us ongoing issues for a while with uWSGI, but we worked with Roberto, the uWSGI author, and managed to get the issues resolved, finally being completely fixed \\(we hope\\) in uWSGI 1.2.6.  \n  \nThe next notable example we ran up against where a major package isn't implementing the WSGI specification correctly is Raven, the Python client for Sentry. We have reported this to David, the Sentry author, but since there is some confusion about what the code should be doing, I am going to use it as an example to explain what the obligations of a WSGI middleware are in relation to the close\\(\\) method, hopefully so I don't have to keep explaining it.  \n  \n\n\n####  What Raven currently does wrong.\n\n  \nThe current code for the Sentry client in Raven is:  \n  \n  \nclass Sentry\\(object\\):  \n\"\"\"  \nA WSGI middleware which will attempt to capture any  \nuncaught exceptions and send them to Sentry.  \n  \n>>> from raven.base import Client  \n>>> application = Sentry\\(application, Client\\(\\)\\)  \n\"\"\"  \ndef \\_\\_init\\_\\_\\(self, application, client\\):  \nself.application = application  \nself.client = client  \n  \ndef \\_\\_call\\_\\_\\(self, environ, start\\_response\\):  \ntry:  \nfor event in self.application\\(environ, start\\_response\\):  \nyield event  \nexcept Exception:  \nexc\\_info = sys.exc\\_info\\(\\)  \nself.handle\\_exception\\(exc\\_info, environ\\)  \nexc\\_info = None  \nraise  \n  \ndef handle\\_exception\\(self, exc\\_info, environ\\):  \nevent\\_id = self.client.capture\\('Exception',  \nexc\\_info=exc\\_info,  \ndata=\\{  \n'sentry.interfaces.Http': \\{  \n'method': environ.get\\('REQUEST\\_METHOD'\\),  \n'url': get\\_current\\_url\\(environ, strip\\_querystring=True\\),  \n'query\\_string': environ.get\\('QUERY\\_STRING'\\),  \n\\# TODO  \n\\# 'data': environ.get\\('wsgi.input'\\),  \n'headers': dict\\(get\\_headers\\(environ\\)\\),  \n'env': dict\\(get\\_environ\\(environ\\)\\),  \n\\}  \n\\},  \n\\)  \nreturn event\\_id  \n  \n  \nThe reason this code is wrong is because it does not satisfy the following requirement from the WSGI specification:  \n\n\n> \"\"\"If the iterable returned by the application has a close\\(\\) method, the server or gateway must call that method upon completion of the current request, whether the request was completed normally, or terminated early due to an application error during iteration or an early disconnect of the browser.\"\"\"\n\nWhat is not entirely clear in the language used here, specifically there only being a reference to 'the server or gateway', is that this obligation extends to WSGI middleware as well.  \n  \nIn other words, although a server or gateway must ensure that close\\(\\) is called on the iterable returned by the application, a WSGI middleware must also ensure that it does the same for any iterable it may consume from a wrapped WSGI application or component.  \n  \nThe code:  \n  \n  \nfor event in self.application\\(environ, start\\_response\\):  \nyield event  \n  \n  \nis therefore incomplete, because although it consumes the iterable returned by the wrapped WSGI application, it does not ensure close\\(\\) is called on it upon completion, or in the event of any errors.  \n  \n\n\n####  Pattern for a generic WSGI middleware.\n\n  \nThere are numerous ways one can structure a WSGI middleware, but following the general pattern used by Raven, a WSGI middleware that does ensure that close\\(\\) is called would be implemented as follows.  \n  \n  \nclass Middleware1\\(object\\):  \n  \ndef \\_\\_init\\_\\_\\(self, application\\):  \nself.application = application  \n  \ndef \\_\\_call\\_\\_\\(self, environ, start\\_response\\):  \niterable = None  \n  \ntry:  \niterable = self.application\\(environ, start\\_response\\)  \nfor data in iterable:  \nyield data  \n  \nfinally:  \nif hasattr\\(iterable, 'close'\\):  \niterable.close\\(\\)  \n  \n  \nImportant to note here is that the act of calling the wrapped application to obtain the iterable has been separated from the process of iterating over it. This is necessary in order that we have a reference to the iterable to call close\\(\\) in the three cases necessary, they being an exception occurring when the actual iterator object itself is being created from the iterable object, if an exception occurs when getting the next item from the iterator object and finally upon the last item being yielded from the iterator.  \n  \nNow because WSGI middleware weren't specifically mentioned in the requirement, it does open up a slight grey area. The problem is the statement:  \n\n\n> \"\"\"must call that method upon completion of the current request\"\"\"\n\nThe intent of that statement, at least from the perspective of the WSGI server, is that close\\(\\) only be called once all content has been consumed from the iterable and that content has been sent to the client.  \n  \nFor a WSGI middleware written as above, that isn't necessarily the point at which it would be called. Instead the close\\(\\) method would get called when the 'for' loop has completed. We have therefore lost any direction association between when close\\(\\) is called by the WSGI server itself upon actual completion of the request and when it is called by the WSGI middleware.  \n  \nOverall, for WSGI middleware it probably isn't a critical issue and having it called immediately the 'for' loop exits is fine. If it were important that close\\(\\) be directly chained, then it would be necessary to implement it differently, instead using.  \n  \n  \nclass Iterable2\\(object\\):  \n  \ndef \\_\\_init\\_\\_\\(self, iterable\\):  \nself.iterable = iterable  \nif hasattr\\(iterable, 'close'\\):  \nself.close = iterable.close  \n  \ndef \\_\\_iter\\_\\_\\(self\\):  \nfor data in self.iterable:  \nyield data  \n  \nclass Middleware2\\(object\\):  \n  \ndef \\_\\_init\\_\\_\\(self, application\\):  \nself.application = application  \n  \ndef \\_\\_call\\_\\_\\(self, environ, start\\_response\\):  \nreturn Iterable2\\(self.application\\(environ, start\\_response\\)\\)  \n  \n  \nThat way the close\\(\\) method is only called for the iterable returned from the wrapped application when close\\(\\) is called by the WSGI server, or any further WSGI middleware that wraps this one.  \n  \nRequiring two classes like this does complicate the implementation of the WSGI middleware however, because both may need to track state for the current request as the iterable is consumed.  \n  \n\n\n####  Correcting the Sentry client in Raven.\n\n  \nAssuming the first pattern for implementing the WSGI middleware is okay, the existing Sentry client in Raven would be rewritten as follows.  \n  \n  \nclass Sentry\\(object\\):  \n  \ndef \\_\\_init\\_\\_\\(self, application, client\\):  \nself.application = application  \nself.client = client  \n  \ndef \\_\\_call\\_\\_\\(self, environ, start\\_response\\):  \niterable = None  \n  \ntry:  \niterable = self.application\\(environ, start\\_response\\)  \nfor event in iterable:  \nyield event  \n  \nexcept Exception:  \nexc\\_info = sys.exc\\_info\\(\\)  \nself.handle\\_exception\\(exc\\_info, environ\\)  \nexc\\_info = None  \nraise  \n  \nfinally:  \nif hasattr\\(iterable, 'close'\\):  \niterable.close\\(\\)  \n  \ndef handle\\_exception\\(self, exc\\_info, environ\\):  \n...  \n\n\n  \n\n\n  \nThis provides the same functionality as it originally performed, but also ensures the close\\(\\) method is called correctly if the iterable provides one.  \n  \nWe are not done though, because technically an exception could be raised by the close\\(\\) method when it is called. Presumably it would be desirable for this also to be captured and reported to Sentry. The more complete solution which does this is:  \n  \n  \nclass Sentry\\(object\\):  \n  \ndef \\_\\_init\\_\\_\\(self, application, client\\):  \nself.application = application  \nself.client = client  \n  \ndef \\_\\_call\\_\\_\\(self, environ, start\\_response\\):  \niterable = None  \n  \ntry:  \niterable = self.application\\(environ, start\\_response\\)  \nfor event in iterable:  \nyield event  \n  \nexcept Exception:  \nexc\\_info = sys.exc\\_info\\(\\)  \nself.handle\\_exception\\(exc\\_info, environ\\)  \nexc\\_info = None  \nraise  \n  \nfinally:  \nif hasattr\\(iterable, 'close'\\):  \ntry:  \niterable.close\\(\\)  \nexcept Exception:  \nexc\\_info = sys.exc\\_info\\(\\)  \nself.handle\\_exception\\(exc\\_info, environ\\)  \nexc\\_info = None  \nraise  \n  \ndef handle\\_exception\\(self, exc\\_info, environ\\):  \n...  \n\n\n  \n\n\n  \n\n\n####  Check what your WSGI middleware does.\n\n  \nSo are you implementing your WSGI middleware correctly?",
  "date": "2012-10-11",
  "author": "Graham Dumpleton",
  "url": "http://blog.dscpl.com.au/2012/10/obligations-for-calling-close-on.html",
  "post_id": "1240502205809946291",
  "blog_id": "2363643920942057324",
  "comments": [
    {
      "comment_id": "8251839024062488494",
      "author": "Rog",
      "author_url": "https://www.blogger.com/profile/17796573390404786648",
      "author_profile_id": "17796573390404786648",
      "content": "Thanks for inestigating and explaining this Graham. As a New Relic, uWSGI and Sentry user, it's good to see collaboration on getting them all working together.  \n  \nFor everyone's reference, it looks like David has committed a change for Raven in response to this...  \nhttps://github.com/getsentry/raven-python/commit/eb6171a24819e16c8e2ba391a3e95c882d7ccbe2\\#raven/middleware.py",
      "timestamp": "October 14, 2012 at 2:11 PM",
      "permalink": "http://blog.dscpl.com.au/2012/10/obligations-for-calling-close-on.html?showComment=1350184275831#c8251839024062488494",
      "is_blog_author": false
    },
    {
      "comment_id": "8437021868975207109",
      "author": "Piotr Dobrogost",
      "author_url": "https://www.blogger.com/profile/09529158749729184143",
      "author_profile_id": "09529158749729184143",
      "content": "Graham, have you spoken with P.J. Eby, author of PEP 333, asking if close\\(\\) should be chained or if it can be called by middleware directly?",
      "timestamp": "October 15, 2012 at 6:52 AM",
      "permalink": "http://blog.dscpl.com.au/2012/10/obligations-for-calling-close-on.html?showComment=1350244326378#c8437021868975207109",
      "is_blog_author": false
    },
    {
      "comment_id": "2190349804146299185",
      "author": "Graham Dumpleton",
      "author_url": "https://www.blogger.com/profile/13609779138164842374",
      "author_profile_id": "13609779138164842374",
      "content": "PJE is by no means the authority on this. Unless things have changed, he has over recent years not been doing a great deal in the area of Python web frameworks. I can think of a bunch of other Python web developers who are likely to be in a much better position to comment.  \n  \nIt also isn't like the pros and cons of each aren't understood. If close\\(\\) is used for resource management, having it called as early as possible after the iterable is consumed is better. If however you are relying on close\\(\\) as a means for performing timing of the complete request for performance monitoring, then requiring close\\(\\) be chained is preferable. This is because if the timing middleware is wrapped and the wrapper doesn't chain, the results will not be as accurate. Although, unless the wrapper is doing something really odd, the difference in timing is likely to be negligible and so insignificant.  \n  \nOverall, because close\\(\\) is so rarely used to actually do anything, the issue would only be of interest to a very small number of people. So it is one of those little details worth noting but that can be ignored for now. If however there were ever a significant update to WSGI it could could be addressed then. I have already given my ideas for how to get rid of close\\(\\) in its current form at the Python web session prior to PyCon this year.",
      "timestamp": "October 15, 2012 at 9:40 AM",
      "permalink": "http://blog.dscpl.com.au/2012/10/obligations-for-calling-close-on.html?showComment=1350254417796#c2190349804146299185",
      "is_blog_author": true
    },
    {
      "comment_id": "6849320109227694054",
      "author": "Piotr Dobrogost",
      "author_url": "https://www.blogger.com/profile/09529158749729184143",
      "author_profile_id": "09529158749729184143",
      "content": "\"PJE is by no means the authority on this.\" Well, I still think it would be valuable to have input from author of the standard you interpret - I notified PJE about your post. Nevertheless thanks for taking time to write detailed comment.",
      "timestamp": "October 15, 2012 at 9:37 PM",
      "permalink": "http://blog.dscpl.com.au/2012/10/obligations-for-calling-close-on.html?showComment=1350297441099#c6849320109227694054",
      "is_blog_author": false
    },
    {
      "comment_id": "241799365773148152",
      "author": "Unknown",
      "author_url": "https://www.blogger.com/profile/05089749636477501534",
      "author_profile_id": "05089749636477501534",
      "content": "Is this a situation where using a context manager would enable the code to be cleaner?",
      "timestamp": "October 19, 2012 at 9:51 AM",
      "permalink": "http://blog.dscpl.com.au/2012/10/obligations-for-calling-close-on.html?showComment=1350600714573#c241799365773148152",
      "is_blog_author": false
    },
    {
      "comment_id": "4370523118489133335",
      "author": "Graham Dumpleton",
      "author_url": "https://www.blogger.com/profile/13609779138164842374",
      "author_profile_id": "13609779138164842374",
      "content": "My suggestion back when talked about future of WSGI at workshop prior to PyCon US this year, was to employ context manager semantics as alternative. This got rid of close\\(\\) as it exists now, but via enter/exit of a context manager allowed for both before and after actions. I will need to try and find out if there is video somewhere and get my slides up on SlideShare.",
      "timestamp": "October 19, 2012 at 11:25 AM",
      "permalink": "http://blog.dscpl.com.au/2012/10/obligations-for-calling-close-on.html?showComment=1350606318949#c4370523118489133335",
      "is_blog_author": true
    },
    {
      "comment_id": "8985349784652025234",
      "author": "Graham Dumpleton",
      "author_url": "https://www.blogger.com/profile/13609779138164842374",
      "author_profile_id": "13609779138164842374",
      "content": "Slides for my talk about state of WSGI 2 and ideas about changing it, including eliminating close\\(\\) can be found at http://www.slideshare.net/GrahamDumpleton/pycon-us-2012-state-of-wsgi-2-14808297",
      "timestamp": "October 20, 2012 at 12:26 PM",
      "permalink": "http://blog.dscpl.com.au/2012/10/obligations-for-calling-close-on.html?showComment=1350696400215#c8985349784652025234",
      "is_blog_author": true
    }
  ],
  "labels": [
    "python",
    "wsgi"
  ],
  "metadata": {
    "published_timestamp": "2012-10-11T14:56:00+11:00",
    "blog_title": "Graham Dumpleton",
    "page_title": "Graham Dumpleton: Obligations for calling close() on the iterable returned by a WSGI application.",
    "og_title": "Obligations for calling close() on the iterable returned by a WSGI application.",
    "og_description": "Despite the  WSGI  specification having been around for so long, one keeps seeing instances where it is implemented wrongly. At New Relic  w...",
    "og_url": "http://blog.dscpl.com.au/2012/10/obligations-for-calling-close-on.html"
  },
  "downloaded_images": []
}