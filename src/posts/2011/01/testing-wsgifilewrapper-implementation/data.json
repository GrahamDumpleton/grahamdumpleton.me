{
  "title": "Testing a wsgi.file_wrapper implementation.",
  "content": "Not many WSGI servers or gateways have attempted to provide an implementation of the wsgi.file\\_wrapper extension. Of those, some provide the callable for generating the file wrapper, but then do not go on to implement any high performance optimisation. Part of the reason for this is that the Python standard library does not expose the UNIX sendfile\\(\\) function. As such, a full implementation of wsgi.file\\_wrapper is usually restricted to WSGI server or gateway implementations implemented directly in C code.  \n  \nDespite the UNIX sendfile\\(\\) call not being present in the Python standard library, it still is possible in a pure Python WSGI server or gateway to fully implement wsgi.file\\_wrapper with optimisations. This can be done by using the ‘ctypes’ module to access and call the underlying UNIX sendfile\\(\\) function. I will explain how to do that in a subsequent blog post, but before doing that I am going to describe a series of tests which can be used to validate the operation of a wsgi.file\\_wrapper implementation.  \n  \nThe first series of tests check aspects of wsgi.file\\_wrapper which would potentially be exercised under normal use. The remainder of the tests try and break implementations by doing unexpected things.  \n  \nThe tests can be used to validate an existing WSGI server or gateway that provides an implementation. They are also a good indicator of what needs to be taken into consideration when actually implementing wsgi.file\\_wrapper and which is why I am presenting them before an actual implementation.  \n  \nNote that the tests assume that wsgi.file\\_wrapper exists and the code doesn’t supply its own alternative if it doesn’t. Thus if your WSGI server or gateway does not implement wsgi.file\\_wrapper at all, the tests will fail in the lookup of wsgi.file\\_wrapper in the first place.  \n  \n**File Objects**  \n  \nThe standard use case is to open a file, wrap it using wsgi.file\\_wrapper and return it.\n    \n    \n    import os  \n    import string  \n      \n    def application(environ, start_response):  \n        status = '200 OK'  \n      \n        response_headers = [('Content-type', 'text/plain')]  \n        start_response(status, response_headers)  \n      \n        filelike = file('/tmp/filetest.txt', 'w')  \n        filelike.write(string.ascii_lowercase)  \n        filelike.close()  \n      \n        filelike = file('/tmp/filetest.txt', 'r')  \n      \n        return environ['wsgi.file_wrapper'](filelike)\n\nIn this case we have not supplied a Content-Length response header. As such, the expectation would be that the complete file should be returned.  \n  \nThe WSGI specification given in PEP 333 doesn’t make any mention about whether a WSGI server or gateway need add a Content-Length if none is supplied, however the revised PEP 3333 does, stating:  \n  \n\"\"\"If the application doesn't supply a Content-Length, the server may generate one from the file using its knowledge of the underlying file implementation.\"\"\"  \n  \nBest practice would be that the Content-Length header is added, especially in the case that sendfile\\(\\) is used to send the file in one big chunk. This is because there isn’t going to be an opportunity to apply HTTP/1.1 chunked encoding on the response content.  \n  \nIf an implementation isn’t attempting to use sendfile\\(\\), but instead is writing the data itself in chunks, then it could if the client protocol was HTTP/1.1, choose to use chunked transfer encoding rather than setting the Content-Length response header. As the content length can be readily calculated though, it would generally be simpler just to set the response header and send the content as is.  \n  \nDo note though that if the WSGI server or gateway is setting the Content-Length response header, then it should ensure that it only sends that amount of data. This would be important where the file to be sent is being appended to, eg., a log file. In other words, once the WSGI server or gateway indicates it will send a certain amount of data, it shouldn’t then just stream till the end of file in case the size of the file has since changed.  \n  \n**File Like Objects**  \n  \nUsing a standard Python file object would be the typical use case, but any file like object can technically be used. For this PEP 3333 says:  \n  \n\"\"\"Note that even if the object is not suitable for the platform API, the wsgi.file\\_wrapper must still return an iterable that wraps read\\(\\) and close\\(\\), so that applications using file wrappers are portable across platforms.\"\"\"  \n  \nThis actually applies in two ways. The first is if the platform itself doesn’t provide a way of dealing with a file object in a performant way, or if a file like object doesn’t provide the attributes which would allow a specific mechanism to be used.  \n  \nThe Windows operating system is an example of the first, whereby the sendfile\\(\\) call is not available. An example of the latter is where rather than a file object being supplied a file like object such as a StringIO object is supplied.  \n  \nOn a UNIX system where an implementation is using sendfile\\(\\), the fallback can therefore be tested using an instance of StringIO.\n    \n    \n    import StringIO  \n    import string  \n      \n    def application(environ, start_response):  \n        status = '200 OK'  \n      \n        response_headers = [('Content-type', 'text/plain')]  \n        start_response(status, response_headers)  \n      \n        filelike = StringIO.StringIO(string.ascii_lowercase)  \n      \n        return environ['wsgi.file_wrapper'](filelike)\n\nEither way, the content accessible should still be written back to the client and the wsgi.file\\_wrapper implementation should not fail.  \n  \nUsing StringIO in particular is a good test because it does not provide a fileno\\(\\) method and if an implementation blindly assumes that a object will always be provided that has a fileno\\(\\) method it will fail. For the case where the implementation is written in C and the PyObject\\_AsFileDescriptor\\(\\) function is used to get the file descriptor the implementation needs to validate that ‘-1’ is not returned and fallback to processing the iterable instead. If this isn’t done, then the implementation may try and access an invalid file descriptor.  \n  \nFor this specific case, we again haven’t supplied a Content-Length and it wouldn’t necessarily be possible to deduce it. As such, if the client protocol was HTTP/1.1, then chunked transfer encoding might be used if the HTTP/WSGI server supports it.  \n  \n**Content Length**  \n  \nNo matter what type of file like object is used, be it an actual file object or otherwise, a WSGI application can optionally set a Content-Length response header itself. This header is meant to be the authoritative indicator as to how much response data is to be returned.  \n  \nIf the Content-Length header is supplied and the value it is given equates to the actual amount of content then there is no problem. If however the given content length is less than the actual amount of data accessible via the file like object, then only that amount of data should be returned and no more.  \n  \nThe WSGI specification as outlined in PEP 333 is actually wrong in this respect in that it says:  \n  \n\"\"\"Apart from the handling of close\\(\\), the semantics of returning a file wrapper from the application should be the same as if the application had returned iter\\(filelike.read, ''\\). In other words, transmission should begin at the current position within the \"file\" at the time that transmission begins, and continue until the end is reached.\"\"\"  \n  \nIn other words, it doesn’t indicate that the Content-Length header should be taken into consideration. PEP 3333 corrects this and states:  \n  \n\"\"\"Apart from the handling of close\\(\\), the semantics of returning a file wrapper from the application should be the same as if the application had returned iter\\(filelike.read, ''\\). In other words, transmission should begin at the current position within the \"file\" at the time that transmission begins, and continue until the end is reached, or until Content-Length bytes have been written.\"\"\"  \n  \nThis scenario needs to be tested and for both a file object and the fallback case for any file like object. Thus would want to perform the test:\n    \n    \n    import os  \n    import string  \n      \n    def application(environ, start_response):  \n        status = '200 OK'  \n      \n        response_headers = [('Content-type', 'text/plain'),  \n                            ('Content-length', str(len(string.ascii_lowercase)/2))]  \n        start_response(status, response_headers)  \n      \n        filelike = file('/tmp/filetest.txt', 'w+')  \n        filelike.write(string.ascii_lowercase)  \n        filelike.close()  \n      \n        filelike = file('/tmp/filetest.txt', 'r')  \n      \n        return environ['wsgi.file_wrapper'](filelike)\n\nand:\n    \n    \n    import StringIO  \n    import string  \n      \n    def application(environ, start_response):  \n        status = '200 OK'  \n      \n        response_headers = [('Content-type', 'text/plain'),  \n                            ('Content-length', str(len(string.ascii_lowercase)/2))]  \n        start_response(status, response_headers)  \n      \n        filelike = StringIO.StringIO(string.ascii_lowercase)  \n      \n        return environ['wsgi.file_wrapper'](filelike)\n\nNote that one can’t rely on using a web browser to validate the output in these cases. This is because a web browser will normally not display any additional data that has been sent beyond what the Content-Length indicated should exist. It is therefore necessary to use a network snooping tool or even telnet directly to the HTTP server port and enter the request and view the raw details of the HTTP response.\n    \n    \n    $ telnet localhost 8000  \n    Trying 127.0.0.1...  \n    Connected to localhost.  \n    Escape character is '^]'.  \n    GET / HTTP/1.0  \n      \n    HTTP/1.1 200 OK  \n    Content-type: text/plain  \n    Content-length: 13  \n      \n    abcdefghijklmnopqrstuvwxyzConnection closed by foreign host.\n\nA valid implementation should only return the amount of data specified by the Content-Length header and no more, thus not what the above output shows.  \n  \n**Current Position**  \n  \nOne of the sections previously quoted from PEP 3333 states:  \n  \n\"\"\"Apart from the handling of close\\(\\), the semantics of returning a file wrapper from the application should be the same as if the application had returned iter\\(filelike.read, ''\\). In other words, transmission should begin at the current position within the \"file\" at the time that transmission begins, and continue until the end is reached, or until Content-Length bytes have been written.\"\"\"  \n  \nKey to note here is the phrase ‘transmission should begin at the current position within the \"file\"’.  \n  \nNormally when a file is opened the current seek position or file pointer will be at the start of the file. This means that where no Content-Length is specified the complete contents of the file would be returned. If however the current position within the file was not at the start of the file, then the complete file should not be returned and instead only from the current position up to the end of the file, or if Content-Length is specified, only that many bytes from the the current position should be returned.  \n  \nTests which validate the correct behaviour for these situations are:\n    \n    \n    import os  \n    import string  \n      \n    def application(environ, start_response):  \n        status = '200 OK'   \n          \n        response_headers = [('Content-type', 'text/plain')]  \n        start_response(status, response_headers)  \n          \n        filelike = file('/tmp/filetest.txt', 'w+')  \n        filelike.write(string.ascii_lowercase)  \n        filelike.flush()  \n          \n        filelike.seek(len(string.ascii_lowercase)/2, os.SEEK_SET)  \n      \n        return environ['wsgi.file_wrapper'](filelike)\n\nand:\n    \n    \n    import os  \n    import string  \n      \n    def application(environ, start_response):  \n        status = '200 OK'   \n          \n        response_headers = [('Content-type', 'text/plain'),  \n                            ('Content-length', str(len(string.ascii_lowercase)/4))]  \n        start_response(status, response_headers)  \n          \n        filelike = file('/tmp/filetest.txt', 'w+')  \n        filelike.write(string.ascii_lowercase)  \n        filelike.flush()  \n          \n        filelike.seek(len(string.ascii_lowercase)/2, os.SEEK_SET)  \n      \n        return environ['wsgi.file_wrapper'](filelike)\n\nFor the first test, from the middle of the file to the end of the file should be returned and if the Content-Length header is set automatically, should correctly reflect that reduced length. The second test should again start from the middle of the file, but should only return 6 characters from the 3rd section of the file.  \n  \nAs with the prior test setting Content-Length, you can’t rely on the browser for the latter test as it will only show as much data as indicated by Content-Length even if more data had actually be returned. A check should therefore be made of the raw HTTP response.  \n  \nThere is no strict need to perform this test where a file like object such as StringIO is used as the way data is consumed in that case means that reading can only start from the current position. An actual file object is different because the optimisation to return the file contents would usually work directly with the file descriptor and not via any high level interface.  \n  \n**Multiple Instances**  \n  \nNow it is time to try and start breaking the wsgi.file\\_wrapper implementation by doing abnormal things. Granted that these things wouldn’t normally be done, but by testing them it tests the robustness of the implementation of wsgi.file\\_wrapper. If an implementation takes short cuts or uses a bad design, then it could result in incorrect behaviour, or in worst case for a C based implementation, cause the process to crash.  \n  \nThe first test that can be done is to use wsgi.file\\_wrapper multiple times within the context of the same request. Obviously only the result of one invocation of wsgi.file\\_wrapper can actually be returned by the WSGI application. This need not even be the result of the last call. No matter which is returned, the original file used with that which is returned should be what is written back to the HTTP client.  \n  \nWe therefore first check for case where last instance of wsgi.file\\_wrapper created is returned.\n    \n    \n    import os  \n    import string  \n      \n    def application(environ, start_response):  \n        status = '200 OK'  \n          \n        response_headers = [('Content-type', 'text/plain'),]  \n        start_response(status, response_headers)  \n          \n        filelike1 = file('/tmp/filetest-a.txt', 'w+')  \n        filelike1.write(string.ascii_lowercase)  \n        filelike1.flush()  \n        filelike1.seek(0, os.SEEK_SET)  \n      \n        file_wrapper1 = environ['wsgi.file_wrapper'](filelike1)  \n      \n        filelike2 = file('/tmp/filetest-b.txt', 'w+')  \n        filelike2.write(string.ascii_uppercase)  \n        filelike2.flush()  \n        filelike2.seek(0, os.SEEK_SET)  \n      \n        file_wrapper2 = environ['wsgi.file_wrapper'](filelike2)  \n      \n        return file_wrapper2\n\nand then the for the case of returning instance of wsgi.file\\_wrapper which wasn’t the last created.\n    \n    \n    import os  \n    import string  \n      \n    def application(environ, start_response):  \n        status = '200 OK'  \n          \n        response_headers = [('Content-type', 'text/plain'),]  \n        start_response(status, response_headers)  \n          \n        filelike1 = file('/tmp/filetest-a.txt', 'w+')  \n        filelike1.write(string.ascii_lowercase)  \n        filelike1.flush()  \n        filelike1.seek(0, os.SEEK_SET)  \n      \n        file_wrapper1 = environ['wsgi.file_wrapper'](filelike1)  \n      \n        filelike2 = file('/tmp/filetest-b.txt', 'w+')  \n        filelike2.write(string.ascii_uppercase)  \n        filelike2.flush()  \n        filelike2.seek(0, os.SEEK_SET)  \n      \n        file_wrapper2 = environ['wsgi.file_wrapper'](filelike2)  \n      \n        return file_wrapper1\n\nWhat is being checked for here is that the implementation isn’t just caching the last inputs given to a call of wsgi.file\\_wrapper and using that. The details must correspond to that used in the instance of wsgi.file\\_wrapper actually returned.  \n  \n**Closed File Object**  \n  \nA file object in Python is a wrapper around a C FILE pointer. In turn the FILE pointer is a wrapper around an actual file descriptor. When performing optimisations to transmit a file using the UNIX sendfile\\(\\) call it is necessary to use the file descriptor. That this is what occurs introduces a couple of complications that need to be catered for.  \n  \nThe first is that the file descriptor and FILE pointer can technically differ as to their understanding of the current seek position within the file. This is because a FILE pointer implements a level of buffering and adjustments to the seek position of the FILE pointer, as well as file contents, may not be reflected in the file descriptor until a flush is performed, writing the data to disk.  \n  \nThe prior test relating to the current position within the file object is intended to try and check for this disparity, although in practice whether it will capture a problem may be dependent on how a specific operating system implements FILE pointers. Important thing to note is that the current position within the file object should be determined by using the ‘tell\\(\\)’ method of the file object and not by interrogating the seek position from the file descriptor. If an implementation gets the information directly from the file descriptor, then ultimately it will likely fail at some point where code is performing seeks on the file object.  \n  \nThe second complication, and which the following test will check, is the fact that there are multiple handles to the actual file. When dealing with a file object, if one closes the file object and then subsequently performs an operation on it a Python exception would be raised. If instead you held a reference to the file descriptor only and the file object was closed, you may not get an error back. This would be the case where the file descriptor had since been reused.  \n  \nAs a result, if an implementation of wsgi.file\\_wrapper caches a reference to the file descriptor up front when first called, and then uses that when writing the file contents back as the response content, if the file object had been closed in between, then the wrong file contents could be returned if the file descriptor had been reused.  \n  \nA correct implementation should delay to the last moment obtaining a reference to the file descriptor. If the file object had been closed in the interim this should see a Python exception if implementation of wsgi.file\\_wrapper is done in Python code, or ‘-1’ being returned by ‘PyObject\\_AsFileDescriptor\\(\\)’ if implemented in C code. If in C code, it should technically then fallback onto attempting to stream the file object, since a non file object would also result in ‘-1’ being returned, in which case it should fail when trying to read data from the file object.  \n  \nThe test for this then is to use wsgi.file\\_wrapper to create the result to return and before that is actually returned close the file object.\n    \n    \n    import os  \n    import string  \n      \n    def application(environ, start_response):  \n        status = '200 OK'  \n          \n        response_headers = [('Content-type', 'text/plain'),]  \n        start_response(status, response_headers)  \n          \n        filelike = file('/tmp/filetest-a.txt', 'w+')  \n        filelike.write(string.ascii_lowercase)  \n        filelike.flush()  \n        filelike.seek(0, os.SEEK_SET)  \n      \n        file_wrapper = environ['wsgi.file_wrapper'](filelike)  \n      \n        filelike.close()  \n      \n        return file_wrapper\n\nOne should also test the variation of where the file object is closed before wsgi.file\\_wrapper is invoked to create the return value for the WSGI application.\n    \n    \n    import os  \n    import string  \n      \n    def application(environ, start_response):  \n        status = '200 OK'  \n          \n        response_headers = [('Content-type', 'text/plain'),]  \n        start_response(status, response_headers)  \n          \n        filelike = file('/tmp/filetest.txt', 'w+')  \n        filelike.write(string.ascii_lowercase)  \n        filelike.flush()  \n        filelike.seek(0, os.SEEK_SET)  \n      \n        filelike.close()  \n      \n        file_wrapper = environ['wsgi.file_wrapper'](filelike)  \n      \n        return file_wrapper\n\nHowever wsgi.file\\_wrapper is implemented, it should result in the error being detected. Because processing of the result is being done after having returned from the WSGI application, the fact that an error occurred would normally be logged in some way and the request terminated with the connection to HTTP client being abruptly closed. That is, there isn’t a way of raising an exception in the context of the original WSGI application.  \n  \nSo, these are the tests. In a future blog post I will show how wsgi.file\\_wrapper should be implemented.",
  "date": "2011-01-22",
  "author": "Graham Dumpleton",
  "url": "http://blog.dscpl.com.au/2011/01/testing-wsgifilewrapper-implementation.html",
  "post_id": "3019441481164740419",
  "blog_id": "2363643920942057324",
  "comments": [
    {
      "comment_id": "1483494576224243517",
      "author": "Marius Gedminas",
      "author_url": "https://www.blogger.com/profile/15155998626202067226",
      "author_profile_id": "15155998626202067226",
      "content": "Excellent\\!  \n  \nDo you plan to build an automated test suite out of this?",
      "timestamp": "January 23, 2011 at 2:57 AM",
      "permalink": "http://blog.dscpl.com.au/2011/01/testing-wsgifilewrapper-implementation.html?showComment=1295711877312#c1483494576224243517",
      "is_blog_author": false
    },
    {
      "comment_id": "5127164062674947938",
      "author": "Graham Dumpleton",
      "author_url": "https://www.blogger.com/profile/13609779138164842374",
      "author_profile_id": "13609779138164842374",
      "content": "There are two sides to automated testing. The client side, which is easy, and the server side, which isn't. The server side is a problem if the intention is to make it easy to apply the tests across multiple WSGI servers as how you deploy a WSGI application with each is different. Even if you focus on just Apache/mod\\_wsgi, it can get complicated if you have to adjust the Apache configuration between requests and restart the server. The old mod\\_python package had a system for doing just this, but it was quite messy. Time is better spent elsewhere at the moment.",
      "timestamp": "January 23, 2011 at 7:34 AM",
      "permalink": "http://blog.dscpl.com.au/2011/01/testing-wsgifilewrapper-implementation.html?showComment=1295728453140#c5127164062674947938",
      "is_blog_author": true
    },
    {
      "comment_id": "3874691770147144653",
      "author": "Graham Dumpleton",
      "author_url": "https://www.blogger.com/profile/13609779138164842374",
      "author_profile_id": "13609779138164842374",
      "content": "For reference, appears that there is a move to have sendfile\\(\\) as part of Python libraries. See http://bugs.python.org/issue10882",
      "timestamp": "January 23, 2011 at 8:18 AM",
      "permalink": "http://blog.dscpl.com.au/2011/01/testing-wsgifilewrapper-implementation.html?showComment=1295731083610#c3874691770147144653",
      "is_blog_author": true
    }
  ],
  "labels": [
    "python",
    "wsgi"
  ],
  "metadata": {
    "published_timestamp": "2011-01-22T17:20:00+11:00",
    "blog_title": "Graham Dumpleton",
    "page_title": "Graham Dumpleton: Testing a wsgi.file_wrapper implementation.",
    "og_title": "Testing a wsgi.file_wrapper implementation.",
    "og_description": "Not many WSGI servers or gateways have attempted to provide an implementation of the wsgi.file_wrapper extension. Of those, some provide the...",
    "og_url": "http://blog.dscpl.com.au/2011/01/testing-wsgifilewrapper-implementation.html"
  },
  "downloaded_images": []
}