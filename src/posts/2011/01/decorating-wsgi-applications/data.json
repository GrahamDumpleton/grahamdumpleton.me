{
  "title": "Decorating WSGI applications.",
  "content": "One of my recent blog posts showed how one could construct a wrapper for a WSGI application component such that a cleanup action could be associated with requests, with the cleanup action only being executed after any request content had been written back to the HTTP client. This time I am going to show how that can be converted into a Python decorator.  \n  \nRecalling the final code from before, what we had was:\n    \n    \n    def FileWrapper(iterable, callback, environ):  \n        class _FileWrapper(type(iterable)):  \n            def close(self):  \n                try:  \n                    iterable.close()  \n                finally:  \n                    callback(environ)  \n        return _FileWrapper(iterable.filelike, iterable.blksize)  \n      \n    class Generator:  \n        def __init__(self, iterable, callback, environ):  \n            self.__iterable = iterable  \n            self.__callback = callback  \n            self.__environ = environ  \n        def __iter__(self):  \n            for item in self.__iterable:  \n                yield item  \n        def close(self):  \n            try:  \n                if hasattr(self.__iterable, 'close'):  \n                    self.__iterable.close()  \n            finally:  \n                self.__callback(self.__environ)  \n      \n    class ExecuteOnCompletion:  \n        def __init__(self, application, callback):  \n            self.__application = application  \n            self.__callback = callback  \n        def __call__(self, environ, start_response):  \n            try:  \n                result = self.__application(environ, start_response)  \n            except:  \n                self.__callback(environ)  \n                raise  \n            file_wrapper = environ.get('wsgi.file_wrapper', None)  \n            if file_wrapper and isinstance(result, file_wrapper):  \n                return FileWrapper(result, self.__callback, environ)  \n            else  \n                return Generator(result, self.__callback, environ)\n\nNote that this is relying on wsgi.file\\_wrapper being a type object, which as explained in prior post probably should be a requirement in a future WSGI specification. I’ll leave it for the example, but you may want to remove that part if concerned about portability.  \n  \nThe above could then be used as:\n    \n    \n    def _application(environ, start_response):  \n        ...  \n      \n    def cleanup(environ):  \n        # Perform required cleanup task.  \n        ...  \n      \n    application = ExecuteOnCompletion(_application, cleanup)\n\nWhat I instead however want to be able to do is write this using the decorator syntax of Python. That is:\n    \n    \n    @execute_on_completion(cleanup)  \n    def application(environ, start_response):  \n        ...\n\nIn another of my recent blog posts I also detailed the different ways that WSGI application objects could be implemented. Namely, as functions, class instances and class objects. As such, we need to make sure it also works for those as well. Specifically:\n    \n    \n    class Application:  \n      \n        @execute_on_completion(cleanup)  \n        def __call__(self, environ, start_response):  \n            ...  \n          \n    application = Application()\n\nand:\n    \n    \n    @execute_on_completion(cleanup)  \n    class Application:  \n      \n        def __init__(self, environ, start_response):  \n            ...  \n              \n        def __iter__(self):  \n            ...  \n      \n    application = Application\n\nFor this decorator we want to be able to use a parameter, namely the reference to the cleanup function. In that case the pattern we will need to use for the implementation of the decorator is:\n    \n    \n    def execute_on_completion(cleanup):  \n        def decorator(application):  \n            def wrapper(environ, start_response):  \n                ...  \n            return wrapper  \n        return decorator\n\nWe already have a wrapper object in the form of the ‘ExecuteOnCompletion’ class though and so don’t need the ‘wrapper\\(\\)’ function here. The result being:\n    \n    \n    def execute_on_completion(cleanup):  \n        def decorator(application):  \n            return ExecuteOnCompletion(application, cleanup)  \n        return decorator\n\nAnd when we try that out for the case where our WSGI application is a normal function:\n    \n    \n    @execute_on_completion(cleanup)  \n    def application(environ, start_response):  \n        status = '200 OK'  \n        response_headers = [('Content-type', 'text/plain')]  \n        start_response(status, response_headers)  \n      \n        return [\"1\\n\", \"2\\n\", \"3\\n\", \"4\\n\", \"5\\n\"]\n\nthat works fine.  \n  \nNow let us however try the case where we use the decorator on a class method:\n    \n    \n    class Application:  \n        @execute_on_completion(cleanup)  \n        def __call__(self, environ, start_response):  \n            status = '200 OK'  \n            response_headers = [('Content-type', 'text/plain')]  \n            start_response(status, response_headers)  \n      \n            return iter([\"1\\n\", \"2\\n\", \"3\\n\", \"4\\n\", \"5\\n\"])  \n      \n    application = Application()\n\nFor this we find it fails. The specific error being:\n    \n    \n    Traceback (most recent call last):  \n      File \"/some/path/example.wsgi\", line 31, in __call__  \n        result = self.__application(environ, start_response)  \n    TypeError: __call__() takes exactly 3 arguments (2 given)\n\nThis is occurring at the point in the ‘\\_\\_call\\_\\_\\(\\)’ method of the ‘ExecuteOnCompletion’ class where the wrapped WSGI application object is being called.  \n  \nI am not going to go into detail here about what the actual cause of the error is, partly because it isn’t something I don’t really understand really well. In summary though, in order to use a class object as a wrapper within a decorator in this way, it needs to have an appropriate descriptor added to it, with the descriptor triggering some magic so that the class method being invoked is seen as a bound method of the class instance, thus ensuring that the ‘self’ parameter is available.  \n  \nBecause descriptors only work for new style classes, which I should have used from the outset anyway, we need to also make ‘ExecuteOnCompletion’ derive from the ‘object’ type. This leaves us with:\n    \n    \n    class ExecuteOnCompletion(object):  \n      \n        def __init__(self, application, callback):  \n            self.__application = application  \n            self.__callback = callback  \n      \n        def __get__(self, obj, objtype=None):  \n            return types.MethodType(self, obj, objtype)  \n      \n        def __call__(self, environ, start_response):  \n            try:  \n                result = self.__application(environ, start_response)  \n            except:  \n                self.__callback(environ)  \n                raise  \n            file_wrapper = environ.get('wsgi.file_wrapper', None)  \n            if file_wrapper and isinstance(result, file_wrapper):  \n                return FileWrapper(result, self.__callback, environ)  \n            else:  \n                return Generator(result, self.__callback, environ)\n\nThe descriptor is the special ‘\\_\\_get\\_\\_\\(\\)’ method which has been added.  \n  \nWe now try again, but it still fails. This time with the different error:\n    \n    \n    TypeError: __call__() takes exactly 3 arguments (4 given)\n\nUnder mod\\_wsgi at least, this didn’t even come with a traceback, possibly because it is coming from C internals of Python, but what is being referred to here is the ‘\\_\\_call\\_\\_\\(\\)’ method of the ‘ExecuteOnCompletion’ class.  \n  \nThe reason the error arises is that with the descriptor being in place, the ‘self’ parameter required when invoking the target WSGI application object is actually being passed in to ‘\\_\\_call\\_\\_\\(\\)’ in addition to the ‘self’ parameter for the instance of ‘ExecuteOnCompletion’ and the ‘environ’ and ‘start\\_response’ parameters.  \n  \nGoing quickly back to our example where we wrapped a normal function and not a class method, we find that adding the descriptor has not changed the operation for that case. At least then the addition of the descriptor hasn’t broken that.  \n  \nWhat it does indicate though is that our ‘\\_\\_call\\_\\_\\(\\)’ method has to be able to handle two scenarios. In the first it will only get passed ‘environ’ and ‘start\\_response’, but when the decorator is applied to a class method, it will also be passed in the ‘self’ parameter for the target WSGI application object, inserted into the argument list before that of ‘environ’ and ‘start\\_response’.  \n  \nNow, we can just change the prototype of the ‘\\_\\_call\\_\\_\\(\\)’ method to accept a variable number of arguments:\n    \n    \n    def __call__(self, *args):  \n      ...\n\nand the actual invocation of the target WSGI application to:\n    \n    \n    result = self.__application(*args)\n\nbut we have the problem that we need access to the ‘environ’ parameter within the body of the ‘\\_\\_call\\_\\_\\(\\)’ method. This being required where needing access to ‘wsgi.file\\_wrapper’ but also so we can pass the ‘environ’ parameter onto the cleanup function.  \n  \nWhat we do know though is that WSGI application objects can only be called with positional parameters and that there is only ever the two of ‘environ’ and ‘start\\_response’. Thus, it doesn’t matter whether there are two or three arguments depending on whether a normal function or a bound class method is being called, the ‘environ’ parameter will always be the second last argument. We can therefore rewrite the ‘\\_\\_call\\_\\_\\(\\)’ method as:\n    \n    \n    class ExecuteOnCompletion(object):  \n      \n        def __init__(self, application, callback):  \n            self.__application = application  \n            self.__callback = callback  \n      \n        def __get__(self, obj, objtype=None):  \n            return types.MethodType(self, obj, objtype)  \n      \n        def __call__(self, *args):  \n            environ = args[-2]  \n            try:  \n                result = self.__application(*args)  \n            except:  \n                self.__callback(environ)  \n                raise  \n            file_wrapper = environ.get('wsgi.file_wrapper', None)  \n            if file_wrapper and isinstance(result, file_wrapper):  \n                return FileWrapper(result, self.__callback, environ)  \n            else:  \n                return Generator(result, self.__callback, environ)\n\nAnd we have success for both the case of the decorator being applied to a normal function, as well as the class method.  \n  \nNow for the final scenario of the decorator being applied to a class.\n    \n    \n    @execute_on_completion(cleanup)  \n    class Application:  \n        def __init__(self, environ, start_response):  \n            self.__environ = environ  \n            self.__start_response = start_response  \n      \n        def __iter__(self):  \n            status = '200 OK'  \n            response_headers = [('Content-type', 'text/plain')]  \n            self.__start_response(status, response_headers)  \n      \n            for item in [\"1\\n\", \"2\\n\", \"3\\n\", \"4\\n\", \"5\\n\"]:  \n                yield item  \n      \n    application = Application\n\nThis also works fine.  \n  \nOne final thing to check is whether this also works if you don’t have access to the source code and need to monkey patch this wrapper to existing code imported from other modules. For example:\n    \n    \n    application = execute_on_completion(cleanup)(application)\n\nAnd the answer to that one is that it does also work for that, so we have pretty well covered all bases.",
  "date": "2011-01-07",
  "author": "Graham Dumpleton",
  "url": "http://blog.dscpl.com.au/2011/01/decorating-wsgi-applications.html",
  "post_id": "8329258324963338074",
  "blog_id": "2363643920942057324",
  "comments": [
    {
      "comment_id": "1101520087913352626",
      "author": "mrploppy",
      "author_url": "https://www.blogger.com/profile/09831815480930381542",
      "author_profile_id": "09831815480930381542",
      "content": "hi graham, do you have any advice on using callbacks where content must be generated before served? i've only just happened across the idea that a request handler is an iterable \\(\\_\\_iter\\_\\_\\). but who calls \\_\\_iter\\_\\_? and can I make it wait for data to be created and serve that?  \ncheers,  \nrobin",
      "timestamp": "November 7, 2014 at 2:18 AM",
      "permalink": "http://blog.dscpl.com.au/2011/01/decorating-wsgi-applications.html?showComment=1415287102530#c1101520087913352626",
      "is_blog_author": false
    },
    {
      "comment_id": "1724415792970438253",
      "author": "Graham Dumpleton",
      "author_url": "https://www.blogger.com/profile/13609779138164842374",
      "author_profile_id": "13609779138164842374",
      "content": "Can't say I understand what you mean. Please us the mod\\_wsgi mailing list to ask your question.",
      "timestamp": "November 7, 2014 at 7:24 AM",
      "permalink": "http://blog.dscpl.com.au/2011/01/decorating-wsgi-applications.html?showComment=1415305464128#c1724415792970438253",
      "is_blog_author": true
    }
  ],
  "labels": [
    "python",
    "wsgi"
  ],
  "metadata": {
    "published_timestamp": "2011-01-07T13:12:00+11:00",
    "blog_title": "Graham Dumpleton",
    "page_title": "Graham Dumpleton: Decorating WSGI applications.",
    "og_title": "Decorating WSGI applications.",
    "og_description": "One of my recent blog posts showed how one could construct a wrapper for a WSGI application component such that a cleanup action could be as...",
    "og_url": "http://blog.dscpl.com.au/2011/01/decorating-wsgi-applications.html"
  },
  "downloaded_images": []
}