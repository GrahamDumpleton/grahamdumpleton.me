{
  "title": "The \"Decorator Pattern\" versus the Python \"wrapt\" package.",
  "content": "Brandon Rhodes published a [post today about the Decorator Pattern](http://python-patterns.guide/gang-of-four/decorator-pattern/) and how that translates into Python. He explains the manual way that the pattern can be implemented in Python as a wrapper, as well as how you can try to minimise the amount of work you need to do by overriding special methods of a Python object.\n\nThe [wrapt](https://pypi.python.org/pypi/wrapt) package I authored was purpose built for this task of creating wrappers which Brandon describes, and much more. To avoid some of the name confusion around Decorator Pattern versus Python decorators, which Brandon highlights as an issue, I tend to refer to the wrappers as transparent object proxies.\n\nLets have a quick look at some of the examples Brandon gave and see how they would be implemented using the wrapt package and what happens when one tries to perform introspection on an object via the wrapper.\n\n# Implement: Dynamic Wrapper\n\nJumping to the example of the dynamic wrapper that Brandon gave, the equivalent using wrapt would be:\n\n```\n import wrapt\n\n class WriteLoggingFile(wrapt.ObjectProxy):\n\n     def __init__(self, wrapped, logger):  \n         super(WriteLoggingFile, self).__init__(wrapped)  \n         self._self_logger = logger\n\n     def write(self, s):  \n         self.__wrapped__.write(s)  \n         self._self_logger.debug('wrote %s bytes to %s', len(s), self.__wrapped__)\n\n     def writelines(self, strings):  \n         if self.closed:  \n             raise ValueError('this file is closed')  \n         for s in strings:  \n             self.write(s)\n```\n\nAll that needed to be provided was the methods you want to override. All that boilerplate functionality of the special methods for attribute access and update, and object iteration etc, are provided by the wrapt.ObjectProxy base class that the wrapper inherits from.\n\nNow lets look at what happens when we introspect an instance of the wrapper object.\n\n```\n >>> import sys, logging  \n >>> stdout = WriteLoggingFile(sys.stdout, logging)  \n >>> dir(stdout)  \n ['__class__', '__delattr__', '__doc__', '__enter__', '__exit__',  \n  '__format__', '__getattribute__', '__hash__', '__init__', '__iter__',  \n  '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__',  \n  '__sizeof__', '__str__', '__subclasshook__', 'close', 'closed',  \n  'encoding', 'errors', 'fileno', 'flush', 'isatty', 'mode', 'name',  \n  'newlines', 'next', 'read', 'readinto', 'readline', 'readlines',  \n  'seek', 'softspace', 'tell', 'truncate', 'write', 'writelines',  \n  'xreadlines']\n```\n\nWe get what we want to see, which is the same as what we would get if we introspect the wrapped object.\n\nThe wrapt.ObjectProxy class does much more than that though. Take for example the following:\n\n```\n >>> isinstance(stdout, type(sys.stdout))  \n True  \n >>> isinstance(stdout, file)  \n True\n```\n\nThe isinstance\\(\\) check will also succeed and say that the wrapper is an instance of the type of object which was wrapped.\n\nIt should be noted that you can't completely fool Python though:\n\n```\n >>> type(stdout)  \n <class '__main__.WriteLoggingFile'>\n```\n\nBut then, if you want to allow for duck typing, you should never directly compare types and should always use isinstance\\(\\).\n\n# Hack: Monkey-patch each object\n\nThe next example which has an equivalent when using wrapt is monkey patching an instance of an object rather than use a wrapper. Using wrapt this would be written as:\n\n```\n def bind_write_method(logger):  \n     @wrapt.function_wrapper  \n     def write_and_log(wrapped, instance, args, kwargs):  \n         wrapped(*args, **kwargs)  \n         logger.debug('wrote %s bytes to %s', len(args[0]), instance)  \n     return write_and_log\n\n f = open('/dev/null', 'w')  \n f.write = bind_write_method(logging)(f.write)\n```\n\nThe @wrapt.function\\_wrapper is a factory for creating a wrapper function. If you have used wrapt before, it does the same job as @wrapt.decorator, but doesn't have as many of the features for customisation that the latter does. When doing monkey patching, using @wrapt.function\\_wrapper is less confusing naming wise as well.\n\nUsing wrapt to do this in this way, introspection even still works correctly on the patched method.\n\n```\n >>> f.write.__name__  \n write\n\n >>> inspect.getargspec(f.write)  \n ArgSpec(args=['self', 'text'], varargs=None, keywords=None, defaults=None)\n```\n\n# Not just for Python decorators\n\nAs shown above, although the wrapt package is probably more well known as being useful for implementing well behaved Python decorators, the primary reason it was created was for implementing the Decorator Pattern for use in monkey-patching Python code dynamically.\n\nMonkey-patching is often regarded as a hack with opinion being that it should never be used. It is absolutely essential though if you want to dynamically instrument Python code to do things like collect metric data without you needing to modify code yourself. In this situation where you would want to use it on production applications, you want to ensure the wrappers work as correctly as properly. That is what the wrapt package aims to do, ensuring as much as possible that all works properly, even in the many obscure corners cases.\n\nIf you still think this is a bad idea and don't trust what wrapt does, you may want to look under the covers of how the two leading application performance monitoring services for Python web applications instrument Python code. Hint, they use wrapt.\n\nIf you want to learn more about wrapt, check out the documentation:\n\n  * [http://wrapt.readthedocs.io](http://wrapt.readthedocs.io/)\n\n\n\nI have also written over a dozen related blog posts on decorators and monkey patching:\n\n  * <http://blog.dscpl.com.au/p/decorators-and-monkey-patching.html>\n\n\n\nFinally, I have presented at a number of conferences on wrapt \\(but not PyCon US\\).\n\n  * <https://www.youtube.com/watch?v=GCZmGgtWi3M>\n\n\n\nI have neglected wrapt a little of late and there are a few outstanding issues that need to be addressed. If you are using wrapt, please let me know via Twitter as getting such messages is always a good motivating force when you work on open source projects. Without such messages it is too easy to get the opinion that no one is using your software and so why you should bother continuing with it.",
  "date": "2018-01-30",
  "author": "Graham Dumpleton",
  "url": "http://blog.dscpl.com.au/2018/01/the-pattern-versus-python-package.html",
  "post_id": "6268623409921269759",
  "blog_id": "2363643920942057324",
  "comments": [],
  "labels": [
    "decorators",
    "python",
    "wrapt"
  ],
  "metadata": {
    "published_timestamp": "2018-01-30T18:31:00+11:00",
    "blog_title": "Graham Dumpleton",
    "page_title": "Graham Dumpleton: The \"Decorator Pattern\" versus the Python \"wrapt\" package.",
    "og_title": "The &quot;Decorator Pattern&quot; versus the Python &quot;wrapt&quot; package.",
    "og_description": "Brandon Rhodes published a post today about the Decorator Pattern  and how that translates into Python. He explains the manual way that the ...",
    "og_url": "http://blog.dscpl.com.au/2018/01/the-pattern-versus-python-package.html"
  },
  "downloaded_images": []
}