{
  "title": "Implementing a universal decorator.",
  "content": "This is the fourth post in my series of blog posts about Python decorators and how I believe they are generally poorly implemented. It follows on from the previous post titled '[Implementing a factory for creating decorators](/posts/2014/01/implementing-factory-for-creating/)', with the very first post in the series being '[How you implemented your Python decorator is wrong](/posts/2014/01/how-you-implemented-your-python/)'.\n\n  \nIn the second post of this series I described a better way of building a decorator which avoided a number of issues I outlined with the typical way in which decorators are coded. This entailed a measure of boiler plate code which needed to be replicated each time. In the previous post to this one I described how we could use a decorator as a decorator factory, and a bit of delegation to hide the boiler plate code and reduce what a user needed to actually declare for a new decorator.  \n  \nIn the prior post I also started to walk through some customisations which could be made to the decorator pattern which would allow the decorator wrapper function provided by a user to ascertain in what context it was used in. That is, for the wrapper function to be able to determine whether it was applied to a function, an instance method, a class method or a class type. The ability to determine the context in this way is what I called a universal decorator, as it avoided the need to have separate decorator implementations for use in each circumstance as is done now with a more traditional way of implementing a decorator.  \n  \nThe walk through got as far as showing how one could distinguish between when the decorator was used on a normal function vs an instance method. Unfortunately the change required to be able to detect when an instance method was called via the class would cause problems for a class method or static method, so we still have a bit more work to do.  \n  \nIn this post I will describe how we can accommodate the cases of a class method and a static method as well as explore other use cases which may give us problems in trying to come up with this pattern for a universal decorator.  \n  \n\n\n###  Normal functions vs instance methods\n\n  \nThe pattern for our universal decorator as described so far was as follows:  \n\n\n```python\nclass bound\\_function\\_wrapper\\(object\\_proxy\\): \n```\n\n```python\ndef \\_\\_init\\_\\_\\(self, wrapped, instance, wrapper\\):  \n super\\(bound\\_function\\_wrapper, self\\).\\_\\_init\\_\\_\\(wrapped\\)  \n self.instance = instance  \n self.wrapper = wrapper \n```\n\n```python\ndef \\_\\_call\\_\\_\\(self, \\*args, \\*\\*kwargs\\):  \n if self.instance is None:  \n instance, args = args\\[0\\], args\\[1:\\]  \n wrapped = functools.partial\\(self.wrapped, instance\\)  \n return self.wrapper\\(wrapped, instance, args, kwargs\\)  \n return self.wrapper\\(self.wrapped, self.instance, args, kwargs\\) \n```\n\n```python\nclass function\\_wrapper\\(object\\_proxy\\): \n```\n\n```python\ndef \\_\\_init\\_\\_\\(self, wrapped, wrapper\\):  \n super\\(function\\_wrapper, self\\).\\_\\_init\\_\\_\\(wrapped\\)  \n self.wrapper = wrapper \n```\n\n```python\ndef \\_\\_get\\_\\_\\(self, instance, owner\\):  \n wrapped = self.wrapped.\\_\\_get\\_\\_\\(instance, owner\\)  \n return bound\\_function\\_wrapper\\(wrapped, instance, self.wrapper\\) \n```\n\n```python\ndef \\_\\_call\\_\\_\\(self, \\*args, \\*\\*kwargs\\):  \n return self.wrapper\\(self.wrapped, None, args, kwargs\\)\n```\n\nThis was used in conjunction with our decorator factory:  \n\n\n```python\ndef decorator\\(wrapper\\):  \n @functools.wraps\\(wrapper\\)  \n def \\_decorator\\(wrapped\\):  \n return function\\_wrapper\\(wrapped, wrapper\\)  \n return \\_decorator\n```\n\nTo test whether everything is working how we want we used our decorator factory to create a decorator which would dump out the values of any instance the wrapped function is bound to, and the arguments passed to the call when executed.  \n\n\n```python\n@decorator  \n def my\\_function\\_wrapper\\(wrapped, instance, args, kwargs\\):  \n print\\('INSTANCE', instance\\)  \n print\\('ARGS', args\\)  \n return wrapped\\(\\*args, \\*\\*kwargs\\) \n```\n\nThis gave us the desired results for when the decorator was applied to a normal function and instance method, including when an instance method was called via the class and the instance passed in explicitly.  \n\n\n```python\n@my\\_function\\_wrapper  \n def function\\(a, b\\):  \n pass\n```\n\n```bash\n>>> function\\(1, 2\\)  \n INSTANCE None  \n ARGS \\(1, 2\\) \n```\n\n```python\nclass Class\\(object\\):  \n @my\\_function\\_wrapper  \n def function\\_im\\(self, a, b\\):  \n pass \n```\n\n> c = Class\\(\\) \n\n```bash\n>>> c.function\\_im\\(1, 2\\)  \n INSTANCE <\\_\\_main\\_\\_.Class object at 0x1085ca9d0>  \n ARGS \\(1, 2\\) \n```\n\n```bash\n>>> Class.function\\_im\\(c, 1, 2\\)  \n INSTANCE <\\_\\_main\\_\\_.Class object at 0x1085ca9d0>  \n ARGS \\(1, 2\\) \n```\n\nThe change to support the latter however, broke things for the case of the decorator being applied to a class method. Similarly for a static method.  \n\n\n```python\nclass Class\\(object\\):  \n @my\\_function\\_wrapper  \n @classmethod  \n def function\\_cm\\(self, a, b\\):  \n pass \n```\n\n```python\n@my\\_function\\_wrapper  \n @staticmethod  \n def function\\_sm\\(a, b\\):  \n pass\n```\n\n```bash\n>>> Class.function\\_cm\\(1, 2\\)  \n INSTANCE 1  \n ARGS \\(2,\\) \n```\n\n```bash\n>>> Class.function\\_sm\\(1, 2\\)  \n INSTANCE 1  \n ARGS \\(2,\\) \n```\n\n###  Class methods and static methods\n\n  \nThe point we are at therefore, is that in the case where the instance is passed as None, we need to be able to distinguish between the three cases of:  \n  \n\n\n  * an instance method being called via the class\n  * a class method being called\n  * a static method being called\n\n  \nOne way this can be done is by looking at the \\_\\_self\\_\\_ attribute of the bound function. This attribute will provide information about the type of object which the function was bound to at that specific point in time. Lets first check this out for where a method is called via the class.  \n\n\n```bash\n>>> print\\(Class.function\\_im.\\_\\_self\\_\\_\\)  \n None \n```\n\n```python\n>>> print\\(Class.function\\_cm.\\_\\_self\\_\\_\\)  \n <class '\\_\\_main\\_\\_.Class'>\n```\n\n```bash\n>>> print\\(Class.function\\_sm.\\_\\_self\\_\\_\\)  \n Traceback \\(most recent call last\\):  \n File \"<stdin>\", line 1, in <module>  \n File \"test.py\", line 19, in \\_\\_getattr\\_\\_  \n return getattr\\(self.wrapped, name\\)  \n AttributeError: 'function' object has no attribute '\\_\\_self\\_\\_'\n```\n\nSo for the case of calling an instance method via the class, \\_\\_self\\_\\_ will be None, for a class method it will be the class type and in the case of a static method, there will not even be a \\_\\_self\\_\\_ attribute. This would therefore appear to give us a way of detecting the different cases.  \n  \nBefore we code up a solution based on this though, lets check with Python 3 just to be sure we are okay there and that nothing has changed.  \n\n\n```bash\n>>> print\\(Class.function\\_im.\\_\\_self\\_\\_\\)  \n Traceback \\(most recent call last\\):  \n File \"<stdin>\", line 1, in <module>  \n File \"dectest.py\", line 19, in \\_\\_getattr\\_\\_  \n return getattr\\(self.wrapped, name\\)  \n AttributeError: 'function' object has no attribute '\\_\\_self\\_\\_' \n```\n\n```python\n>>> print\\(Class.function\\_cm.\\_\\_self\\_\\_\\)  \n <class '\\_\\_main\\_\\_.Class'>\n```\n\n```bash\n>>> print\\(Class.function\\_sm.\\_\\_self\\_\\_\\)  \n Traceback \\(most recent call last\\):  \n File \"<stdin>\", line 1, in <module>  \n File \"test.py\", line 19, in \\_\\_getattr\\_\\_  \n return getattr\\(self.wrapped, name\\)  \n AttributeError: 'function' object has no attribute '\\_\\_self\\_\\_'\n```\n\nThat isn't good, Python 3 behaves differently to Python 2, meaning we aren't going to be able to use this approach. Why is this case?  \n  \nThe reason for this is that in Python 3 they decided to eliminate the idea of an unbound method and this check was relying on the fact that when accessing an instance method via the class, it would actually return an instance of an unbound method for which the \\_\\_self\\_\\_ attribute was None. So although we can distinguish the case for a class method still, we can now no longer distinguish the case of calling an instance method via the class, from the case of calling a static method.  \n  \nThe lack of this ability therefore leaves us with a bit of a problem for Python 3 and the one alternative isn't necessarily a completely fool proof way of doing it.  \n  \nThis alternative is in the constructor of the function wrapper, to look at the type of the wrapped object and determine if it is an instance of a class method or static method. This information can then be passed through to the bound function wrapper and checked.  \n\n\n```python\nclass bound\\_function\\_wrapper\\(object\\_proxy\\): \n```\n\n```python\ndef \\_\\_init\\_\\_\\(self, wrapped, instance, wrapper, binding\\):  \n super\\(bound\\_function\\_wrapper, self\\).\\_\\_init\\_\\_\\(wrapped\\)  \n self.instance = instance  \n self.wrapper = wrapper  \n self.binding = binding \n```\n\n```python\ndef \\_\\_call\\_\\_\\(self, \\*args, \\*\\*kwargs\\):  \n if self.binding == 'function' and self.instance is None:  \n instance, args = args\\[0\\], args\\[1:\\]  \n wrapped = functools.partial\\(self.wrapped, instance\\)  \n return self.wrapper\\(wrapped, instance, args, kwargs\\) \n```\n\n> return self.wrapper\\(self.wrapped, self.instance, args, kwargs\\) \n\n```python\nclass function\\_wrapper\\(object\\_proxy\\): \n```\n\n```python\ndef \\_\\_init\\_\\_\\(self, wrapped, wrapper\\):  \n super\\(function\\_wrapper, self\\).\\_\\_init\\_\\_\\(wrapped\\)  \n self.wrapper = wrapper \n```\n\n```python\nif isinstance\\(wrapped, classmethod\\):  \n self.binding = 'classmethod'  \n elif isinstance\\(wrapped, staticmethod\\):  \n self.binding = 'staticmethod'  \n else:  \n self.binding = 'function' \n```\n\n```python\ndef \\_\\_get\\_\\_\\(self, instance, owner\\):  \n wrapped = self.wrapped.\\_\\_get\\_\\_\\(instance, owner\\)  \n return bound\\_function\\_wrapper\\(wrapped, instance, self.wrapper, self.binding\\) \n```\n\n```python\ndef \\_\\_call\\_\\_\\(self, \\*args, \\*\\*kwargs\\):  \n return self.wrapper\\(self.wrapped, None, args, kwargs\\)\n```\n\nNow this test is a bit fragile, but as I showed before though, the traditional way that a decorator is written will fail if wrapped around a class method or static method as it doesn't honour the descriptor protocol. As such it is a pretty safe bet right now that I will only ever find an actual class method or static method object because no one would be using decorators around them.  \n  \nIf someone is actually implementing the descriptor protocol in their decorator, hopefully they would also be using an object proxy as is done here. Because the object proxy implements \\_\\_class\\_\\_ as a property, it would return the class of the wrapped object, this should mean that an isinstance\\(\\) check will still be successful as isinstance\\(\\) gives priority to what \\_\\_class\\_\\_ yields rather than the actual type of the object.  \n  \nAnyway, trying out our tests again with this change we get:  \n\n\n```bash\n>>> c.function\\_im\\(1,2\\)  \n INSTANCE <\\_\\_main\\_\\_.Class object at 0x101f973d0>  \n ARGS \\(1, 2\\) \n```\n\n```bash\n>>> Class.function\\_im\\(c, 1, 2\\)  \n INSTANCE <\\_\\_main\\_\\_.Class object at 0x101f973d0>  \n ARGS \\(1, 2\\)\n```\n\n```bash\n>>> c.function\\_cm\\(1,2\\)  \n INSTANCE <\\_\\_main\\_\\_.Class object at 0x101f973d0>  \n ARGS \\(1, 2\\)\n```\n\n```bash\n>>> Class.function\\_cm\\(1, 2\\)  \n INSTANCE None  \n ARGS \\(1, 2\\) \n```\n\n```bash\n>>> c.function\\_sm\\(1,2\\)  \n INSTANCE <\\_\\_main\\_\\_.Class object at 0x101f973d0>  \n ARGS \\(1, 2\\) \n```\n\n```bash\n>>> Class.function\\_sm\\(1, 2\\)  \n INSTANCE None  \n ARGS \\(1, 2\\)\n```\n\nSuccess, we have fixed the issue with the argument list when both a class method and a static method are called.  \n  \nThe problem now is that although the instance argument is fine for the case of an instance method call, whether that be via the instance or the class, the instance as passed for a class method and static method aren't particularly useful as we can't use it to distinguish them from other cases.  \n  \nIdeally what we want in this circumstance is that for a class method call we want the instance argument to always be the class type, and for the case of a static method call, for it to always be None.  \n  \nFor the case of a static method, we could just check for 'staticmethod' from when we checked the type of object which was wrapped.  \n  \nFor the case of a class method, if we look back at our test to see if we could use the \\_\\_self\\_\\_ attribute, what we found was that for the class method, \\_\\_self\\_\\_ was the class instance and for a static method the attribute didn't exist.  \n  \nWhat we can therefore do, is if the type of the wrapped object wasn't a function, then we can lookup up the value of \\_\\_self\\_\\_, defaulting to None if it doesn't exist. This one check will cater for both cases.  \n  \nWhat we now therefore have is:  \n\n\n```python\nclass bound\\_function\\_wrapper\\(object\\_proxy\\):  \n def \\_\\_init\\_\\_\\(self, wrapped, instance, wrapper, binding\\):  \n super\\(bound\\_function\\_wrapper, self\\).\\_\\_init\\_\\_\\(wrapped\\)  \n self.instance = instance  \n self.wrapper = wrapper  \n self.binding = binding \n```\n\n```python\ndef \\_\\_call\\_\\_\\(self, \\*args, \\*\\*kwargs\\):  \n if self.binding == 'function':  \n if self.instance is None:  \n instance, args = args\\[0\\], args\\[1:\\]  \n wrapped = functools.partial\\(self.wrapped, instance\\)  \n return self.wrapper\\(wrapped, instance, args, kwargs\\)  \n else:  \n return self.wrapper\\(self.wrapped, self.instance, args, kwargs\\)  \n else:  \n instance = getattr\\(self.wrapped, '\\_\\_self\\_\\_', None\\)  \n return self.wrapper\\(self.wrapped, instance, args, kwargs\\)\n```\n\nand if we run our tests one more time, we finally get the result we have been looking for:  \n\n\n```bash\n>>> c.function\\_im\\(1,2\\)  \n INSTANCE <\\_\\_main\\_\\_.Class object at 0x10c2c43d0>  \n ARGS \\(1, 2\\) \n```\n\n```bash\n>>> Class.function\\_im\\(c, 1, 2\\)  \n INSTANCE <\\_\\_main\\_\\_.Class object at 0x10c2c43d0>  \n ARGS \\(1, 2\\) \n```\n\n```python\n>>> c.function\\_cm\\(1,2\\)  \n INSTANCE <class '\\_\\_main\\_\\_.Class'>  \n ARGS \\(1, 2\\) \n```\n\n```python\n>>> Class.function\\_cm\\(1, 2\\)  \n INSTANCE <class '\\_\\_main\\_\\_.Class'>  \n ARGS \\(1, 2\\) \n```\n\n```bash\n>>> c.function\\_sm\\(1,2\\)  \n INSTANCE None  \n ARGS \\(1, 2\\) \n```\n\n```bash\n>>> Class.function\\_sm\\(1, 2\\)  \n INSTANCE None  \n ARGS \\(1, 2\\)\n```\n\nAre we able to celebrate yet? Unfortunately not.  \n  \n\n\n###  Multiple levels of binding\n\n  \nThere is yet another obscure case we have yet to consider, one that I didn't even think of initially and only understood the problem when I started to see code breaking in crazy ways.  \n  \nThis is when we take a reference to a method and reassign it back again as an attribute of a class, or even an instance of a class, and then call it via the alias so created. I only encountered this one due to some bizarre stuff a meta class was doing.  \n\n\n```python\n>>> Class.function\\_rm = Class.function\\_im  \n >>> c.function\\_rm\\(1, 2\\)  \n INSTANCE 1  \n ARGS \\(2,\\)  \n Traceback \\(most recent call last\\):  \n File \"<stdin>\", line 1, in <module>  \n File \"test.py\", line 132, in \\_\\_call\\_\\_  \n return self.wrapper\\(wrapped, instance, args, kwargs\\)  \n File \"test.py\", line 58, in my\\_function\\_wrapper  \n return wrapped\\(\\*args, \\*\\*kwargs\\)  \n TypeError: unbound method function\\_im\\(\\) must be called with Class instance as first argument \\(got int instance instead\\) \n```\n\n```python\n>>> Class.function\\_rm = Class.function\\_cm  \n >>> c.function\\_rm\\(1, 2\\)  \n INSTANCE <class '\\_\\_main\\_\\_.Class'>  \n ARGS \\(1, 2\\) \n```\n\n```bash\n>>> Class.function\\_rm = Class.function\\_sm  \n >>> c.function\\_rm\\(1, 2\\)  \n INSTANCE None  \n ARGS \\(1, 2\\)\n```\n\nThings work fine for a class method or static method, but fails badly for an instance method.  \n  \nThe problem here comes about because in accessing the instance method the first time, it will return a bound function wrapper. That then gets assigned back as an attribute of the class.  \n  \nWhen a subsequent lookup is made via the new name, under normal circumstances binding would occur once more to bind it to the actual instance. In our implementation of the bound function wrapper, we do not however provide a \\_\\_get\\_\\_\\(\\) method and thus this rebinding does not occur. The result is that on the subsequent call, it all falls apart.  \n  \nThe solution therefore is that we need to add a \\_\\_get\\_\\_\\(\\) method to the bound function wrapper which provides the ability to perform further binding. We only want to do this where the instance was None, indicating that the initial binding wasn't actually against an instance, and where we are dealing with an instance method and not a class method or static method.  \n  \nA further wrinkle is that we need to bind what was the original wrapped function and not the bound one. The simplest way of handling that is to pass a reference to the original function wrapper to the  \nbound function wrapper and reach back into that to get the original wrapped function.  \n\n\n```python\nclass bound\\_function\\_wrapper\\(object\\_proxy\\): \n```\n\n```python\ndef \\_\\_init\\_\\_\\(self, wrapped, instance, wrapper, binding, parent\\):  \n super\\(bound\\_function\\_wrapper, self\\).\\_\\_init\\_\\_\\(wrapped\\)  \n self.instance = instance  \n self.wrapper = wrapper  \n self.binding = binding  \n self.parent = parent \n```\n\n```python\ndef \\_\\_call\\_\\_\\(self, \\*args, \\*\\*kwargs\\):  \n if self.binding == 'function':  \n if self.instance is None:  \n instance, args = args\\[0\\], args\\[1:\\]  \n wrapped = functools.partial\\(self.wrapped, instance\\)  \n return self.wrapper\\(wrapped, instance, args, kwargs\\)  \n else:  \n return self.wrapper\\(self.wrapped, self.instance, args, kwargs\\)  \n else:  \n instance = getattr\\(self.wrapped, '\\_\\_self\\_\\_', None\\)  \n return self.wrapper\\(self.wrapped, instance, args, kwargs\\) \n```\n\n```python\ndef \\_\\_get\\_\\_\\(self, instance, owner\\):  \n if self.instance is None and self.binding == 'function':  \n descriptor = self.parent.wrapped.\\_\\_get\\_\\_\\(instance, owner\\)  \n return bound\\_function\\_wrapper\\(descriptor, instance, self.wrapper,  \n self.binding, self.parent\\)  \n return self \n```\n\n```python\nclass function\\_wrapper\\(object\\_proxy\\): \n```\n\n```python\ndef \\_\\_init\\_\\_\\(self, wrapped, wrapper\\):  \n super\\(function\\_wrapper, self\\).\\_\\_init\\_\\_\\(wrapped\\)  \n self.wrapper = wrapper  \n if isinstance\\(wrapped, classmethod\\):  \n self.binding = 'classmethod'  \n elif isinstance\\(wrapped, staticmethod\\):  \n self.binding = 'staticmethod'  \n else:  \n self.binding = 'function' \n```\n\n```python\ndef \\_\\_get\\_\\_\\(self, instance, owner\\):  \n wrapped = self.wrapped.\\_\\_get\\_\\_\\(instance, owner\\)  \n return bound\\_function\\_wrapper\\(wrapped, instance, self.wrapper,  \n self.binding, self\\) \n```\n\n```python\ndef \\_\\_call\\_\\_\\(self, \\*args, \\*\\*kwargs\\):  \n return self.wrapper\\(self.wrapped, None, args, kwargs\\)\n```\n\nRerunning our most recent test once again we now get:  \n\n\n```bash\n>>> Class.function\\_rm = Class.function\\_im  \n >>> c.function\\_rm\\(1, 2\\)  \n INSTANCE <\\_\\_main\\_\\_.Class object at 0x105609790>  \n ARGS \\(1, 2\\) \n```\n\n```python\n>>> Class.function\\_rm = Class.function\\_cm  \n >>> c.function\\_rm\\(1, 2\\)  \n INSTANCE <class '\\_\\_main\\_\\_.Class'>  \n ARGS \\(1, 2\\) \n```\n\n```bash\n>>> Class.function\\_rm = Class.function\\_sm  \n >>> c.function\\_rm\\(1, 2\\)  \n INSTANCE None  \n ARGS \\(1, 2\\)\n```\n\n###  Order that decorators are applied\n\nWe must be getting close now. Everything appears to be working.  \n  \nIf you had been paying close attention you would have noticed though that in all cases so far our decorator has always been placed outside of the existing decorators marking a method as either a class method or a static method. What happens if we reverse the order?  \n\n\n```python\nclass Class\\(object\\):  \n @classmethod  \n @my\\_function\\_wrapper  \n def function\\_cm\\(self, a, b\\):  \n pass \n```\n\n```python\n@staticmethod  \n @my\\_function\\_wrapper  \n def function\\_sm\\(a, b\\):  \n pass \n```\n\n> c = Class\\(\\) \n\n```python\n>>> c.function\\_cm\\(1,2\\)  \n INSTANCE None  \n ARGS \\(<class '\\_\\_main\\_\\_.Class'>, 1, 2\\) \n```\n\n```python\n>>> Class.function\\_cm\\(1, 2\\)  \n INSTANCE None  \n ARGS \\(<class '\\_\\_main\\_\\_.Class'>, 1, 2\\) \n```\n\n```bash\n>>> c.function\\_sm\\(1,2\\)  \n INSTANCE None  \n ARGS \\(1, 2\\) \n```\n\n```bash\n>>> Class.function\\_sm\\(1, 2\\)  \n INSTANCE None  \n ARGS \\(1, 2\\)\n```\n\nSo it works as we would expect for a static method but not for a class method.  \n  \nAt this point you gotta be thinking why I am bothering.  \n  \nAs it turns out there is indeed absolutely nothing I can do about this one. But that isn't actually my fault.  \n  \nIn this particular case, it actually can be seen as being a bug in Python itself. Specifically, the classmethod decorator doesn't itself honour the descriptor protocol when it calls whatever it is wrapping. This is the exact same problem I faulted decorators implemented using a closure for originally. If it wasn't for the classmethod decorator doing the wrong thing, everything would be perfect.  \n  \nFor those who are interested in the details, you can check out [issue 19072](http://bugs.python.org/issue19072) in the Python bug tracker. If I had tried hard I could well have got it fixed by the time Python 3.4 came out, but I simply didn't have the time nor the real motivation to satisfy all the requirements to get the fix accepted.  \n  \n\n\n###  Decorating a class\n\n  \nExcluding that one case related to ordering of decorators for class methods, our pattern for implementing a universal decorator is looking good.  \n  \nI did mention though in the last post that the goal was that we could also distinguish when a decorator was applied to a class. So lets check that.  \n\n\n```python\n@my\\_function\\_wrapper  \n class Class\\(object\\):  \n pass \n```\n\n```bash\n>>> c = Class\\(\\)  \n INSTANCE None  \n ARGS \\(\\)\n```\n\nBased on that we aren't able to distinguish it from a normal function or a class method.  \n  \nIf we think about it though, we are in this case wrapping an actual class, so the wrapped object which is passed to the decorator wrapper function will be the class itself. Lets print out the value of the wrapped argument passed to the decorator wrapper function as well and see whether that can be used to distinguish this case from others.  \n\n\n```python\n@decorator  \n def my\\_function\\_wrapper\\(wrapped, instance, args, kwargs\\):  \n print\\('WRAPPED', wrapped\\)  \n print\\('INSTANCE', instance\\)  \n print\\('ARGS', args\\)  \n return wrapped\\(\\*args, \\*\\*kwargs\\) \n```\n\n```python\n@my\\_function\\_wrapper  \n def function\\(a, b\\):  \n pass \n```\n\n```bash\n>>> function\\(1, 2\\)  \n WRAPPED <function function at 0x10e13bb18>  \n INSTANCE None  \n ARGS \\(1, 2\\) \n```\n\n```python\nclass Class\\(object\\):  \n @my\\_function\\_wrapper  \n def function\\_im\\(self, a, b\\):  \n pass  \n @my\\_function\\_wrapper  \n @classmethod  \n def function\\_cm\\(self, a, b\\):  \n pass  \n @my\\_function\\_wrapper  \n @staticmethod  \n def function\\_sm\\(a, b\\):  \n pass \n```\n\n> c = Class\\(\\) \n\n```bash\n>>> c.function\\_im\\(1,2\\)  \n WRAPPED <bound method Class.function\\_im of <\\_\\_main\\_\\_.Class object at 0x107e90950>>  \n INSTANCE <\\_\\_main\\_\\_.Class object at 0x107e90950>  \n ARGS \\(1, 2\\) \n```\n\n```bash\n>>> Class.function\\_im\\(c, 1, 2\\)  \n WRAPPED <functools.partial object at 0x107df3208>  \n INSTANCE <\\_\\_main\\_\\_.Class object at 0x107e90950>  \n ARGS \\(1, 2\\) \n```\n\n```python\n>>> c.function\\_cm\\(1,2\\)  \n WRAPPED <bound method type.function\\_cm of <class '\\_\\_main\\_\\_.Class'>>  \n INSTANCE <class '\\_\\_main\\_\\_.Class'>  \n ARGS \\(1, 2\\) \n```\n\n```python\n>>> Class.function\\_cm\\(1, 2\\)  \n WRAPPED <bound method type.function\\_cm of <class '\\_\\_main\\_\\_.Class'>>  \n INSTANCE <class '\\_\\_main\\_\\_.Class'>  \n ARGS \\(1, 2\\) \n```\n\n```bash\n>>> c.function\\_sm\\(1,2\\)  \n WRAPPED <function function\\_sm at 0x107e918c0>  \n INSTANCE None  \n ARGS \\(1, 2\\) \n```\n\n```bash\n>>> Class.function\\_sm\\(1, 2\\)  \n WRAPPED <function function\\_sm at 0x107e918c0>  \n INSTANCE None  \n ARGS \\(1, 2\\) \n```\n\n```python\n@my\\_function\\_wrapper  \n class Class\\(object\\):  \n pass \n```\n\n> c = Class\\(\\) \n\n```python\n>>> c = Class\\(\\)  \n WRAPPED <class '\\_\\_main\\_\\_.Class'>  \n INSTANCE None  \n ARGS \\(\\)\n```\n\nAnd the answer is yes, as it is the only case where wrapped will be a type object.  \n  \n\n\n###  The structure of a universal decorator\n\n  \nThe goal of a decorator, one decorator, that can be implemented and applied to normal functions, instance methods, class methods and classes is therefore achievable. The odd one out is static methods, but in practice these aren't really different to normal functions, just being contained in a different scope, so I think I will let that one slide.  \n  \nThe information to identify the static method is actually available in the way the decorator works, but since there is nothing in the arguments passed to a static method that link it to the class it is contained in, there doesn't seem a point. If that information was required, it probably should have been a class method to begin with.  \n  \nAnyway, after all this work, our universal decorator then would be written as:  \n\n\n```python\n@decorator  \n def universal\\(wrapped, instance, args, kwargs\\):  \n if instance is None:  \n if inspect.isclass\\(wrapped\\):  \n \\# Decorator was applied to a class.  \n return wrapped\\(\\*args, \\*\\*kwargs\\)  \n else:  \n \\# Decorator was applied to a function or staticmethod.  \n return wrapped\\(\\*args, \\*\\*kwargs\\)  \n else:  \n if inspect.isclass\\(instance\\):  \n \\# Decorator was applied to a classmethod.  \n return wrapped\\(\\*args, \\*\\*kwargs\\)  \n else:  \n \\# Decorator was applied to an instancemethod.  \n return wrapped\\(\\*args, \\*\\*kwargs\\)\n```\n\nAre there actual uses for such a universal decorator? I believe there are some quite good examples and I will cover one in particular in a subsequent blog post.  \n  \nYou also have frameworks such as Django which already use hacks to allow a decorator designed for use with a function, to be applied to an instance method. Turns out that the method they use is broken because it doesn't honour the descriptor protocol though. If you are interested in that one, see [issue 21247](https://code.djangoproject.com/ticket/21247) in the Django bug tracker.  \n  \nI will not cover this example of a use case for a universal decorator just yet. Instead in my next blog post in this series I will look at issues around having decorators that have optional arguments and how to capture any such arguments so the decorator can make use of them.",
  "date": "Thursday, January 9, 2014",
  "author": "Graham Dumpleton",
  "url": "http://blog.dscpl.com.au/2014/01/implementing-universal-decorator.html",
  "post_id": "7588699231967083693",
  "blog_id": "2363643920942057324",
  "comments": [
    {
      "comment_id": "5768868610626710319",
      "author": "Unknown",
      "author_url": "https://www.blogger.com/profile/09154445172172701979",
      "author_profile_id": "09154445172172701979",
      "content": "In your first post on decorators your set a goal of \"Preservation of function argument specification\", but after applying universal decorator, you described here, i still get a \"TypeError: <...> is not a code object\" when calling inspect.getargs\\(\\) on decorated function.  \n  \nIs this not possible to preserve argspec?",
      "timestamp": "January 10, 2014 at 11:09 PM",
      "permalink": "http://blog.dscpl.com.au/2014/01/implementing-universal-decorator.html?showComment=1389355770662#c5768868610626710319",
      "is_blog_author": false
    },
    {
      "comment_id": "387408894311700040",
      "author": "Graham Dumpleton",
      "author_url": "https://www.blogger.com/profile/13609779138164842374",
      "author_profile_id": "13609779138164842374",
      "content": "In the blog post I said the example of the object proxy shown was not complete, you need the full implementation of that. Use the 'wrapt' package off PyPi and if you still have a problem create an issue on github project for package.",
      "timestamp": "January 11, 2014 at 7:27 AM",
      "permalink": "http://blog.dscpl.com.au/2014/01/implementing-universal-decorator.html?showComment=1389385627995#c387408894311700040",
      "is_blog_author": true
    },
    {
      "comment_id": "1730756527016902037",
      "author": "Dave Brondsema",
      "author_url": "https://www.blogger.com/profile/04987092211724707506",
      "author_profile_id": "04987092211724707506",
      "content": "This series is awesome. Extremely detailed and informative - a lot that I didn't know. Thanks :\\)",
      "timestamp": "January 11, 2014 at 2:55 PM",
      "permalink": "http://blog.dscpl.com.au/2014/01/implementing-universal-decorator.html?showComment=1389412533556#c1730756527016902037",
      "is_blog_author": false
    },
    {
      "comment_id": "570404661381272229",
      "author": "Graham Dumpleton",
      "author_url": "https://www.blogger.com/profile/13609779138164842374",
      "author_profile_id": "13609779138164842374",
      "content": "Actually looking up the documentation, the inspect.getargs\\(\\) call is meant to be given a code object, not a function. Thus it is meant to be called as inspect.getargs\\(function.\\_\\_code\\_\\_\\). I suspect you were mistaking it with inspect.getargspec\\(\\) which should work fine.",
      "timestamp": "January 11, 2014 at 8:33 PM",
      "permalink": "http://blog.dscpl.com.au/2014/01/implementing-universal-decorator.html?showComment=1389432835943#c570404661381272229",
      "is_blog_author": true
    },
    {
      "comment_id": "9139619847519737862",
      "author": "Unknown",
      "author_url": "https://www.blogger.com/profile/09154445172172701979",
      "author_profile_id": "09154445172172701979",
      "content": "My bad, inspect.getargspec works just fine.  \n  \nAnd thank you for this post series, they are awesome.",
      "timestamp": "January 13, 2014 at 6:51 PM",
      "permalink": "http://blog.dscpl.com.au/2014/01/implementing-universal-decorator.html?showComment=1389599471482#c9139619847519737862",
      "is_blog_author": false
    }
  ],
  "labels": [
    "decorators",
    "python"
  ],
  "metadata": {
    "published_timestamp": "2014-01-09T23:06:00+11:00",
    "blog_title": "Graham Dumpleton",
    "page_title": "Graham Dumpleton: Implementing a universal decorator.",
    "og_title": "Implementing a universal decorator.",
    "og_description": " This is the fourth post in my series of blog posts about Python decorators and how I believe they are generally poorly implemented. It foll...",
    "og_url": "http://blog.dscpl.com.au/2014/01/implementing-universal-decorator.html"
  },
  "downloaded_images": []
}