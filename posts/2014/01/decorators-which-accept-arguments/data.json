{
  "title": "Decorators which accept arguments.",
  "content": "This is the fifth post in my series of blog posts about Python decorators and how I believe they are generally poorly implemented. It follows on from the previous post titled '[Implementing a universal decorator](/posts/2014/01/implementing-universal-decorator/)', with the very first post in the series being '[How you implemented your Python decorator is wrong](/posts/2014/01/how-you-implemented-your-python/)'.  \n  \nSo far in this series of posts I have explained the short comings of implementing a decorator in the traditional way they are done in Python. I have shown an alternative implementation based on an object proxy and a descriptor which solves these issues, as well as provides the ability to implement what I call a universal decorator. That is, a decorator which understands the context it was used in and can determine whether it was applied to a normal function, an instance method, a class method or a class type.  \n  \nIn this post, I am going to take the decorator factory which was described in the previous posts and describe how one can use that to implement decorators which accept arguments. This will cover mandatory arguments, but also how to have the one decorator optionally except arguments.  \n  \n\n\n###  Pattern for creating decorators\n\n  \nThe key component of what was described in the prior posts was a function wrapper object. I am not going to replicate the code for that here so see the prior posts. In short though, it was a class type which accepted the function to be wrapped and a user supplied wrapper function. The instance of the resulting function wrapper object was used in place of the wrapped function and when called, would delegate the calling of the wrapped function to the user supplied wrapper function. This allows a user to modify how the call was made, performing actions before or after the wrapped function was called, or modify input arguments or the result.  \n  \nThis function wrapper was used in conjunction with the decorator factory which was also described:  \n\n\n> def decorator\\(wrapper\\):  \n>  @functools.wraps\\(wrapper\\)  \n>  def \\_decorator\\(wrapped\\):  \n>  return function\\_wrapper\\(wrapped, wrapper\\)  \n>  return \\_decorator\n\nallowing a user to define their own decorator as:  \n\n\n> @decorator  \n>  def my\\_function\\_wrapper\\(wrapped, instance, args, kwargs\\):  \n>  print\\('INSTANCE', instance\\)  \n>  print\\('ARGS', args\\)  \n>  print\\('KWARGS', kwargs\\)  \n>  return wrapped\\(\\*args, \\*\\*kwargs\\) \n\n> @my\\_function\\_wrapper  \n>  def function\\(a, b\\):  \n>  pass\n\nIn this example, the final decorator which is created does not accept any arguments, but if we did want the decorator to be able to accept arguments, with the arguments accessible at the time the user supplied wrapper function was called, how would we do that?  \n  \n\n\n###  Using a function closure to collect arguments\n\n  \nThe easiest way to implement a decorator which accepts arguments is using a function closure.  \n\n\n> def with\\_arguments\\(arg\\):  \n>  @decorator  \n>  def \\_wrapper\\(wrapped, instance, args, kwargs\\):  \n>  return wrapped\\(\\*args, \\*\\*kwargs\\)  \n>  return \\_wrapper \n\n> @with\\_arguments\\(arg=1\\)  \n>  def function\\(\\):  \n>  pass\n\nIn effect the outer function is a decorator factory in its own right, where a distinct decorator instance will be returned which is customised according to what arguments were supplied to the outer decorator factory function.  \n  \nSo, when this outer decorator factory function is applied to a function with the specific arguments supplied, it returns the inner decorator function and it is actually that which is applied to the function to be wrapped. When the wrapper function is eventually called and it in turn calls the wrapped function, it will have access to the original arguments to the outer decorator factory function by virtue of being part of the function closure.  \n  \nPositional or keyword arguments can be used with the outer decorator factory function, but I would suggest that keyword arguments are perhaps a better convention to adopt as I will show later.  \n  \nWhat now if a decorator with arguments had default values and as such they could be left out from the call. With this way of implementing the decorator, even though one would not need to pass the argument, one cannot avoid needing to still write it out as a distinct call. That is, you still need to supply empty parentheses.  \n\n\n> def with\\_arguments\\(arg='default'\\):  \n>  @decorator  \n>  def \\_wrapper\\(wrapped, instance, args, kwargs\\):  \n>  return wrapped\\(\\*args, \\*\\*kwargs\\)  \n>  return \\_wrapper \n\n> @with\\_arguments\\(\\)  \n>  def function\\(\\):  \n>  pass\n\nAlthough this is being specific and would dictate there be only one way to do it, it can be felt that this looks ugly. As such some people like to have a way that the parentheses are optional if the decorator arguments all have default values and none are being supplied explicitly. In other words, the desire is that when there are no arguments to be passed, that one can write:  \n\n\n> @with\\_arguments  \n>  def function\\(\\):  \n>  pass\n\nThere is actually some merit in this idea when looked at the other way around. That is, if a decorator originally accepted no arguments, but it was determined later that it needed to be changed to optionally accept arguments, then if the parentheses could be optional, it would allow arguments to now be accepted, without needing to go back and change all prior uses of the original decorator where no arguments were supplied.  \n  \n\n\n###  Optionally allowing decorator arguments\n\n  \nTo allow the decorator arguments to be optionally supplied, we can change the above recipe to:  \n\n\n> def optional\\_arguments\\(wrapped=None, arg=1\\):  \n>  if wrapped is None:  \n>  return functools.partial\\(optional\\_arguments, arg=arg\\) \n\n> @decorator  \n>  def \\_wrapper\\(wrapped, instance, args, kwargs\\):  \n>  return wrapped\\(\\*args, \\*\\*kwargs\\)  \n>  return \\_wrapper\\(wrapped\\) \n\n> @optional\\_arguments\\(arg=2\\)  \n>  def function1\\(\\):  \n>  pass\n\n> @optional\\_arguments  \n>  def function2\\(\\):  \n>  pass \n\nWith the arguments having default values, the outer decorator factory would take the wrapped function as first argument with None as a default. The decorator arguments follow. Decorator arguments would need to be passed as keyword arguments. On the first call, wrapped will be None, and a partial is used to return the decorator factory again. On the second call, wrapped is passed and this time it is wrapped with the decorator.  \n  \nBecause we have default arguments though, we don't actually need to pass the arguments, in which case the decorator factory is applied direct to the function being decorated. Because wrapped is not None when passed in, the decorator is wrapped around the function immediately, skipping the return of the factory a second time.  \n  \nNow why I said a convention of having keyword arguments may perhaps be preferable, is that Python 3 allows you to enforce it using the new keyword only argument syntax.  \n\n\n> def optional\\_arguments\\(wrapped=None, \\*, arg=1\\):\n\n> if wrapped is None:  \n>  return functools.partial\\(optional\\_arguments, arg=arg\\) \n\n> @decorator  \n>  def \\_wrapper\\(wrapped, instance, args, kwargs\\):  \n>  return wrapped\\(\\*args, \\*\\*kwargs\\)  \n>  return \\_wrapper\\(wrapped\\)\n\nThis way you avoid the problem of someone accidentally passing in a decorator argument as the positional argument for wrapped. For consistency, keyword only arguments can also be enforced for required arguments even though it isn't strictly necessary.  \n\n\n> def required\\_arguments\\(\\*, arg\\):  \n>  @decorator  \n>  def \\_wrapper\\(wrapped, instance, args, kwargs\\):  \n>  return wrapped\\(\\*args, \\*\\*kwargs\\)  \n>  return \\_wrapper \n\n  \n\n\n###  Maintaining state between wrapper calls\n\n  \n\n\nQuite often a decorator doesn't perform an isolated task for each invocation of a function it may be applied to. Instead it may need to maintain state between calls. A classic example of this is a cache decorator.\n\n  \n\n\nIn this scenario, because no state information can be maintained within the wrapper function itself, any state object needs to be maintained in an outer scope which the wrapper has access to.\n\n  \n\n\nThere are a few ways in which this can be done.\n\n  \n\n\nThe first is to require that the object which maintains the state, be passed in as an explicit argument to the decorator.\n\n> def cache\\(d\\):  \n>  @decorator  \n>  def \\_wrapper\\(wrapped, instance, args, kwargs\\):  \n>  try:  \n>  key = \\(args, frozenset\\(kwargs.items\\(\\)\\)\\)  \n>  return d\\[key\\]  \n>  except KeyError:  \n>  result = d\\[key\\] = wrapped\\(\\*args, \\*\\*kwargs\\)  \n>  return result  \n>  return \\_wrapper \n\n> \\_d = \\{\\} \n\n> @cache\\(\\_d\\)  \n>  def function\\(\\):  \n>  return time.time\\(\\)\n\nUnless there is a specific need to be able to pass in the state object, a second better way is to create the state object on the stack within the call of the outer function.\n\n> def cache\\(wrapped\\):  \n>  d = \\{\\}  \n>  @decorator  \n>  def \\_wrapper\\(wrapped, instance, args, kwargs\\):  \n>  try:  \n>  key = \\(args, frozenset\\(kwargs.items\\(\\)\\)\\)  \n>  return d\\[key\\]  \n>  except KeyError:  \n>  result = d\\[key\\] = wrapped\\(\\*args, \\*\\*kwargs\\)  \n>  return result  \n>  return \\_wrapper\\(wrapped\\) \n\n> @cache  \n>  def function\\(\\):  \n>  return time.time\\(\\)\n\nIn this case the outer function rather than taking a decorator argument, is taking the function to be wrapped. This is then being explicitly wrapped by the decorator defined within the function and returned.\n\n  \n\n\nIf this was a reasonable default, but you did in some cases still need to optionally pass the state object in as an argument, then optional decorator arguments could instead be used.\n\n> def cache\\(wrapped=None, d=None\\):  \n>  if wrapped is None:  \n>  return functools.partial\\(cache, d=d\\) \n\n> if d is None:  \n>  d = \\{\\} \n\n> @decorator  \n>  def \\_wrapper\\(wrapped, instance, args, kwargs\\):  \n>  try:  \n>  key = \\(args, frozenset\\(kwargs.items\\(\\)\\)\\)  \n>  return d\\[key\\]  \n>  except KeyError:  \n>  result = d\\[key\\] = wrapped\\(\\*args, \\*\\*kwargs\\)  \n>  return result  \n>  return \\_wrapper\\(wrapped\\) \n\n> @cache  \n>  def function1\\(\\):  \n>  return time.time\\(\\) \n\n> \\_d = \\{\\} \n\n> @cache\\(d=\\_d\\)  \n>  def function2\\(\\):  \n>  return time.time\\(\\) \n\n> @cache\\(d=\\_d\\)  \n>  def function3\\(\\):  \n>  return time.time\\(\\)\n\n  \n\n\n###  Decorators as a class\n\n  \n\n\nNow way back in the very first post in this series of blog posts, a way in which a decorator could be implemented as a class was described.\n\n> class function\\_wrapper\\(object\\):  \n>  def \\_\\_init\\_\\_\\(self, wrapped\\):  \n>  self.wrapped = wrapped  \n>  def \\_\\_call\\_\\_\\(self, \\*args, \\*\\*kwargs\\):  \n>  return self.wrapped\\(\\*args, \\*\\*kwargs\\)\n\nAlthough this had short comings which were explained and which resulted in the alternate decorator pattern being presented, this original approach is also able to maintain state. Specifically, the constructor of the class can save away the state object as an attribute of the instance of the class, along with the reference to the wrapped function.\n\n> class cache\\(object\\):  \n>  def \\_\\_init\\_\\_\\(self, wrapped\\):  \n>  self.wrapped = wrapped  \n>  self.d = \\{\\}  \n>  def \\_\\_call\\_\\_\\(self, \\*args, \\*\\*kwargs\\):  \n>  try:  \n>  key = \\(args, frozenset\\(kwargs.items\\(\\)\\)\\)  \n>  return self.d\\[key\\]  \n>  except KeyError:  \n>  result = self.d\\[key\\] = self.wrapped\\(\\*args, \\*\\*kwargs\\)  \n>  return result \n\n> @cache  \n>  def function\\(\\):  \n>  return time.time\\(\\)\n\nUse of a class in this way had some benefits in that where the work of the decorator was quite complex, it could all be encapsulated in the class implementing the decorator itself.\n\n  \n\n\nWith our new function wrapper and decorator factory, the user can only supply the wrapper as a function, which would appear to limit being able to implement a direct equivalent.\n\n  \n\n\nOne could still use a class to encapsulate the required behaviour, with an instance of the class created within the scope of a function closure for use by the wrapper function, and the wrapper function then delegating to that, but it isn't self contained as it was before.\n\n  \n\n\nThe question is, is there any way that one could still achieve the same thing with our new decorator pattern. Turns out there possibly is. \n\n  \n\n\nWhat one should be able to do, at least for where there are required arguments, is do:\n\n> class with\\_arguments\\(object\\): \n\n> def \\_\\_init\\_\\_\\(self, arg\\):  \n>  self.arg = arg \n\n> @decorator  \n>  def \\_\\_call\\_\\_\\(self, wrapped, instance, args, kwargs\\):  \n>  return wrapped\\(\\*args, \\*\\*kwargs\\) \n\n> @with\\_arguments\\(arg=1\\)  \n>  def function\\(\\):  \n>  pass\n\nWhat will happen here is that application of the decorator with arguments being supplied, will result in an instance of the class being created. In the next phase where that is called with the wrapped function, the \\_\\_call\\_\\_\\(\\) method with @decorator applied will be used as a decorator on the wrapped function. The end result should be that the \\_\\_call\\_\\_\\(\\) method of the class instance created ends up being our wrapper function.\n\n  \n\n\nWhen the decorated function is now called, the \\_\\_call\\_\\_\\(\\) method of the class would be called to then in turn call the wrapped function. As the \\_\\_call\\_\\_\\(\\) method at that point is bound to an instance of the class, it would have access to the state that it contained.\n\n  \n\n\nWhat actually happens when we do this though?\n\n> Traceback \\(most recent call last\\):  \n>  File \"test.py\", line 483, in <module>  \n>  @with\\_arguments\\(1\\)  \n>  TypeError: \\_decorator\\(\\) takes exactly 1 argument \\(2 given\\)\n\nSo nice idea, but it fails.  \n  \nIs it game over? The answer is of course not, because if it isn't obvious by now, I don't give up that easily.  \n  \nNow the reason this failed is actually because of how our decorator factory is implemented.\n\n> def decorator\\(wrapper\\):  \n>  @functools.wraps\\(wrapper\\)  \n>  def \\_decorator\\(wrapped\\):  \n>  return function\\_wrapper\\(wrapped, wrapper\\)  \n>  return \\_decorator\n\nI will not describe in this post what the problem is though and will leave the solving of this particular problem to a short followup post as the next in this blog post series on decorators.",
  "date": "Saturday, January 11, 2014",
  "author": "Graham Dumpleton",
  "url": "http://blog.dscpl.com.au/2014/01/decorators-which-accept-arguments.html",
  "post_id": "3880361329029302762",
  "blog_id": "2363643920942057324",
  "comments": [
    {
      "comment_id": "6604829576083653998",
      "author": "ionelmc",
      "author_url": "https://www.blogger.com/profile/01597626721526324841",
      "author_profile_id": "01597626721526324841",
      "content": "Can you please change the code blocks to use fixed font and some colors ? Descriptor code is hard enough to read already :-\\)",
      "timestamp": "January 12, 2014 at 3:24 AM",
      "permalink": "http://blog.dscpl.com.au/2014/01/decorators-which-accept-arguments.html?showComment=1389457466510#c6604829576083653998",
      "is_blog_author": false
    },
    {
      "comment_id": "2267028667636953340",
      "author": "Graham Dumpleton",
      "author_url": "https://www.blogger.com/profile/13609779138164842374",
      "author_profile_id": "13609779138164842374",
      "content": "Changing formatting is not that simple unfortunately. The blog runs on Google blogger which historically has been a pain when it comes to trying to show code snippets. As soon as you start mucking with formatting it screws things up. There is definitely no way of easily adding syntax colouring. I was happy at least this time that I could get indenting to work and I didn't need to waste huge amounts of time constantly trying to fix up what blogger screws up. So I left it at that. I will try with future posts to see if blogger has fixed anything since last time I tried to be tricky with formatting.",
      "timestamp": "January 12, 2014 at 12:57 PM",
      "permalink": "http://blog.dscpl.com.au/2014/01/decorators-which-accept-arguments.html?showComment=1389491839075#c2267028667636953340",
      "is_blog_author": true
    },
    {
      "comment_id": "4203976835832020447",
      "author": "Jonathan Hepp",
      "author_url": "https://www.blogger.com/profile/02657472499212023674",
      "author_profile_id": "02657472499212023674",
      "content": "I have been using Github Gists. It allows integration with most blogging platforms painlessly.",
      "timestamp": "January 12, 2014 at 11:20 PM",
      "permalink": "http://blog.dscpl.com.au/2014/01/decorators-which-accept-arguments.html?showComment=1389529255962#c4203976835832020447",
      "is_blog_author": false
    },
    {
      "comment_id": "4451760819615499528",
      "author": "ionelmc",
      "author_url": "https://www.blogger.com/profile/01597626721526324841",
      "author_profile_id": "01597626721526324841",
      "content": "You could embed github gists. But then you have this external dependency ...",
      "timestamp": "January 12, 2014 at 11:56 PM",
      "permalink": "http://blog.dscpl.com.au/2014/01/decorators-which-accept-arguments.html?showComment=1389531381456#c4451760819615499528",
      "is_blog_author": false
    },
    {
      "comment_id": "7792115564553597400",
      "author": "Graham Dumpleton",
      "author_url": "https://www.blogger.com/profile/13609779138164842374",
      "author_profile_id": "13609779138164842374",
      "content": "As well as the external dependency, I would be more worried about getting things right when you have a large number of little code snippets in a post. For a single large code snippet it could well work okay, although the narrow width of blogger text area may result in the need to scroll sideways within the embedded area, which could be more annoying.",
      "timestamp": "January 13, 2014 at 10:17 AM",
      "permalink": "http://blog.dscpl.com.au/2014/01/decorators-which-accept-arguments.html?showComment=1389568629225#c7792115564553597400",
      "is_blog_author": true
    }
  ],
  "labels": [
    "decorators",
    "python"
  ],
  "metadata": {
    "published_timestamp": "2014-01-11T23:05:00+11:00",
    "blog_title": "Graham Dumpleton",
    "page_title": "Graham Dumpleton: Decorators which accept arguments.",
    "og_title": "Decorators which accept arguments.",
    "og_description": "This is the fifth post in my series of blog posts about Python decorators and how I believe they are generally poorly implemented. It follow...",
    "og_url": "http://blog.dscpl.com.au/2014/01/decorators-which-accept-arguments.html"
  },
  "downloaded_images": []
}