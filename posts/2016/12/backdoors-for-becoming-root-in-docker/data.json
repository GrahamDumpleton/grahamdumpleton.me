{
  "title": "Backdoors for becoming root in a Docker container.",
  "content": "In my last [post](/posts/2016/12/what-user-should-you-use-to-run-docker/), the main issue I looked at was whether you can trust what a Docker-formatted image says about the user it will run as. What we found was that if the ‘USER’ statement is used in a Dockefile, but is set to a name, you have no idea what UNIX user ID the application in the container will run as. This is because the name could be mapped to any user ID by the UNIX passwd file.\n\nSetting up the UNIX passwd file such that a user name other than ‘root’ also mapped to the UID of 0 provided a backdoor to becoming root in the running container. By requiring that an integer UID be used with the ‘USER’ statement in a Dockerfile, we can inspect the image metadata and decide not to run the image if ‘USER’ wasn’t a non zero integer value.\n\nIs this enough to protect us though? Are there other backdoors for becoming ‘root' in a Docker container. The answer to that is that there is, and this post will look at some of these ways.\n\n# Creating a setuid executable\n\nThe primary path for switching from a non privileged user to the ‘root’ user on a UNIX system is a setuid executable. This is an executable that has been blessed in such a way that instead of running as the user that ran it, it runs as the user who is the owner of the executable. Such setuid executables will also work inside of a Docker container.\n\nTo illustrate how a setuid executable works, lets look at the UNIX utility called ‘id', which is normally used to display information about what user and group the invoking process runs as. If run normally in our Docker container, we might see:\n\n```bash\n    $ id  \n    uid=1001(app) gid=1001(app) groups=1001(app)\n```\n\nLets create a setuid version of the executable which is owned by ‘root' and bundle that in our image.\n\n```dockerfile\n    FROM centos:centos7\n\n    RUN groupadd --gid 1001 app  \n    RUN useradd --uid 1001 --gid app --home /app app\n\n    RUN cp /usr/bin/id /usr/bin/id-setuid-root  \n    RUN chmod 4711 /usr/bin/id-setuid-root\n\n    WORKDIR /app  \n    USER 1001\n```\n\nRunning the original version of ‘id’ and the setuid version, we get:\n\n```bash\n    $ id  \n    uid=1001(app) gid=1001(app) groups=1001(app)\n\n    $ id-setuid-root  \n    uid=1001(app) gid=1001(app) euid=0(root) groups=1001(app)\n```\n\nAs can be seen, the result is that although the real user ID is the same, the effective user ID is that of the ‘root’ user. This means that by using a setuid executable, we gain the rights to run something as if we are ‘root’, or at least very close to being ‘root’. I say very close to being ‘root’ as it is only the effective user ID which is ‘root’ and not the real user ID. In most cases it doesn’t matter, but it hardly matters anyway, as we could also switch our real identify to the ‘root’ user relatively easily from a custom setuid executable of our own.\n\n# Running programs as 'root'\n\nIn the above example we took an existing executable and made it setuid as the ‘root’ user. We can’t go and do this for every executable we want to run as ‘root’, so what do we do if we want to run an arbitrary executable as ‘root’?\n\nYou might think that is simple. All we need to do is make a copy of ‘/bin/bash’ and make it setuid as the ‘root’ user. If we can then run that, we can become ‘root’ and run any program we want as the ‘root’ user.\n\nSo this time to create the image we use:\n\n```dockerfile\n    FROM centos:centos7\n\n    RUN groupadd --gid 1001 app  \n    RUN useradd --uid 1001 --gid app --home /app app\n\n    RUN cp /bin/bash /bin/bash-setuid-root  \n    RUN chmod 4711 /bin/bash-setuid-root\n\n    WORKDIR /app  \n    USER 1001\n```\n\nRunning our setuid version of bash though, we don’t get what we expected.\n\n```bash\n    bash-4.2$ id  \n    uid=1001(app) gid=1001(app) groups=1001(app)\n\n    bash-4.2$ bash-setuid-root\n\n    bash-setuid-root-4.2$ id  \n    uid=1001(app) gid=1001(app) groups=1001(app)\n```\n\nThis doesn’t work because modern implementations of shells have checks builtin which look for the specific case of where they are executed with an effective user ID of ‘root’, but a non ‘root’ real user ID. In this case, just to make it harder to use this sort of backdoor, they will revert back to running as the real user ID for the effective user ID.\n\nSince this doesn’t work, lets look at how we would achieve the same thing if we weren’t trying to use a backdoor.\n\nThe first method we would normally use to execute a command as the ‘root’ user when we are not a privileged user, is to use the ‘sudo’ command. An alternative is to use the ‘su’ command to login as the ‘root’ user.\n\nBecause in a Docker image we can install and configure anything we want, there is no reason why we can’t just set these up and use them.\n\n```python\n    FROM centos:centos7\n\n    RUN yum install -y sudo\n\n    RUN groupadd --gid 1001 app  \n    RUN useradd --uid 1001 --gid app --home /app app\n\n    # Allow anyone in group 'app' to use 'sudo' without a password.  \n    RUN echo '%app ALL=(ALL) NOPASSWD: ALL' >> /etc/sudoers\n\n    # Set the password for the 'root' user to be an empty string.  \n    RUN echo 'root:' | chpasswd\n\n    WORKDIR /app  \n    USER 1001\n```\n\nWith this we can very easily get an interactive shell as the ‘root’ user using ’sudo’, not even requiring a password.\n\n```bash\n    $ id  \n    uid=1001(app) gid=1001(app) groups=1001(app)\n\n    $ sudo -s\n\n    # id  \n    uid=0(root) gid=0(root) groups=0(root)\n```\n\nWe can also just login as the ‘root’ user, supplying our empty password.\n\n```bash\n    $ id  \n    uid=1001(app) gid=1001(app) groups=1001(app)\n\n    $ su root  \n    Password:\n\n    # id  \n    uid=0(root) gid=0(root) groups=0(root)\n```\n\nIn both cases the real user ID is that of the ‘root’ user and not just the effective user ID.\n\nSo we didn’t even need to fiddle with a backdoor, we can just use the existing features of the operating system. We just need to install the ‘sudo’ package and configure it, or set the ‘root’ password. As it happens, both these mechanisms rely on a setuid executable, but combine it with configuration to guard against who can access them. It is a simple matter though to enable that access given that during the build of a Docker image you can change anything.\n\n# You can’t completely block 'root'\n\nYou might be thinking at this point that if we can become the ‘root’ user in these ways, what is the point then of using a check on what ‘USER’ specified for the image in the first place. Someone can always set it as a non ‘root’ user, using an integer UID to avoid any restriction on using the image, but then use a custom built backdoor marked as a setuid executable, or using existing system tools such as ‘sudo’, or ‘su’.\n\nWhat is important to understand is that good security is based on having many layers. You don’t rely on just a single security measure to protect your system. Each extra layer you can add, acts as an obstacle to someone reaching their end goal. Not allowing images to run that don’t set ‘USER’ to a non zero integer ID, would be just one step you can take in a overall security plan.\n\nSo it isn’t a waste of time just yet. This is because, although there are ways of becoming the ‘root’ user even if ‘USER’ did not originally declare the container should run as ‘root’, we can still control what the ‘root’ user is actually able to do. This is achieved using Linux capabilities, and is the next layer of defence you should employ.\n\nIn the next blog post I will look at Linux capabilities and how to use Docker to restrict what someone could do even if they become the ‘root’ user.",
  "date": "Friday, December 9, 2016",
  "author": "Graham Dumpleton",
  "url": "http://blog.dscpl.com.au/2016/12/backdoors-for-becoming-root-in-docker.html",
  "post_id": "6615292119161107706",
  "blog_id": "2363643920942057324",
  "comments": [
    {
      "comment_id": "7712885679699988041",
      "author": "JustAQuestion",
      "author_url": "https://www.blogger.com/profile/10219072188332078733",
      "author_profile_id": "10219072188332078733",
      "content": "Hello,  \n  \nNot related to this blog, but related to debugging to debugging. I tried folowing modwsgi doc, but not successful, getting these error messages  \n  \nArgsAlreadyParsedError: arguments already parsed: cannot register CLI option  \n  \nI couldnt find another avenue to reach out to you. Please let me know if there is a e-mail that can be used.  \n  \nrunning httpd -X and embedded mode to get to pdb shell  \n  \nwsgi-keystone.conf is  \n  \nWSGIProcessGroup %\\{GLOBAL\\}  \n  \nremoved this line:WSGIDaemonProcess keystone-public processes=5 threads=1 user=keystone group=keystone  \n  \nThanks,  \nAshok",
      "timestamp": "February 22, 2017 at 2:21 AM",
      "permalink": "http://blog.dscpl.com.au/2016/12/backdoors-for-becoming-root-in-docker.html?showComment=1487690500084#c7712885679699988041",
      "is_blog_author": false
    },
    {
      "comment_id": "5060471924117824759",
      "author": "Graham Dumpleton",
      "author_url": "https://www.blogger.com/profile/13609779138164842374",
      "author_profile_id": "13609779138164842374",
      "content": "For mod\\_wsgi questions use the mod\\_wsgi mailing list. Details at:  \n  \nhttp://modwsgi.readthedocs.io/en/develop/finding-help.html",
      "timestamp": "February 22, 2017 at 10:28 AM",
      "permalink": "http://blog.dscpl.com.au/2016/12/backdoors-for-becoming-root-in-docker.html?showComment=1487719687834#c5060471924117824759",
      "is_blog_author": true
    }
  ],
  "labels": [
    "docker"
  ],
  "metadata": {
    "published_timestamp": "2016-12-09T16:22:00+11:00",
    "blog_title": "Graham Dumpleton",
    "page_title": "Graham Dumpleton: Backdoors for becoming root in a Docker container.",
    "og_title": "Backdoors for becoming root in a Docker container.",
    "og_description": "In my last post , the main issue I looked at was whether you can trust what a Docker-formatted image says about the user it will run as. Wha...",
    "og_url": "http://blog.dscpl.com.au/2016/12/backdoors-for-becoming-root-in-docker.html"
  },
  "downloaded_images": []
}