{
  "title": "WSGI middleware and the hidden write() callable.",
  "content": "When I posted recently about the [obligations of a WSGI server or middleware to call close\\(\\)](/posts/2012/10/obligations-for-calling-close-on/) on the iterable returned from a WSGI application, I posted a pattern for a WSGI middleware of:  \n  \n  \nclass Middleware\\(object\\):  \n  \ndef \\_\\_init\\_\\_\\(self, application\\):  \nself.application = application  \n  \ndef \\_\\_call\\_\\_\\(self, environ, start\\_response\\):  \niterable = None  \n  \ntry:  \niterable = self.application\\(environ, start\\_response\\)  \nfor data in iterable:  \nyield data  \n  \nfinally:  \nif hasattr\\(iterable, 'close'\\):  \niterable.close\\(\\)  \n  \n  \nIn this example, as each block of data was consumed from the iterable of the WSGI application, it was immediately yielded. The use of yield in turn caused the result returned from the '\\_\\_call\\_\\_\\(\\)' method to be a generator satisfying the requirement that a WSGI application or middleware return an iterable.  \n  \nThis WSGI middleware will work for the specific case of response content being passed through unmodified, but things get a bit more complicated if it were wanting to actually modify the response content.  \n  \nConsider for example the following.  \n  \n  \nclass Middleware\\(object\\):  \n  \ndef \\_\\_init\\_\\_\\(self, application\\):  \nself.application = application  \n  \ndef transform\\(self, data\\):  \nreturn data.upper\\(\\)  \n  \ndef \\_\\_call\\_\\_\\(self, environ, start\\_response\\):  \niterable = None  \n  \ntry:  \niterable = self.application\\(environ, start\\_response\\)  \nfor data in iterable:  \nyield self.transform\\(data\\)  \n  \nfinally:  \nif hasattr\\(iterable, 'close'\\):  \niterable.close\\(\\)  \n  \nAlthough it looks entirely reasonable, this WSGI middleware is not correct.  \n  \nWhat is missing from this WSGI middleware is handling of the 'write\\(\\)' callable that is returned by 'start\\_response\\(\\)' and which can be used as an alternative to returning data via the iterable returned from the WSGI application.  \n  \nIf the above WSGI middleware was used to wrap a WSGI application which used that 'write\\(\\)' callable, then the response wouldn't actually be transformed as intended.  \n  \nHaving to deal with the 'write\\(\\)' callable in WSGI middleware is a pain and unduly makes writing WSGI middleware potentially quite complicated as you need to track two data paths through the WSGI middleware. It is even possible that response content may be provided by both 'write\\(\\)' and via the iterable for the same request.  \n  \nA revised version of the WSGI middleware which supports the 'write\\(\\)' callable is:  \n  \n  \nclass Middleware\\(object\\):  \n  \ndef \\_\\_init\\_\\_\\(self, application\\):  \nself.application = application  \n  \ndef transform\\(self, data\\):  \nreturn data.upper\\(\\)  \n  \ndef \\_\\_call\\_\\_\\(self, environ, start\\_response\\):  \n  \ndef \\_start\\_response\\(status, response\\_headers, \\*args\\):  \nwrite = start\\_response\\(status, response\\_headers, \\*args\\)  \ndef \\_write\\(data\\): write\\(self.transform\\(data\\)\\)  \nreturn \\_write  \n  \niterable = None  \n  \ntry:  \niterable = self.application\\(environ, \\_start\\_response\\)  \nfor data in iterable:  \nyield self.transform\\(data\\)  \n  \nfinally:  \nif hasattr\\(iterable, 'close'\\):  \niterable.close\\(\\)  \n  \nThat 'write\\(\\)' exists and how to deal with it in WSGI middleware which is transforming a response is often glossed over in tutorials on WSGI. It is somewhat lucky then that most people resort to using web frameworks because it would be a point which would be easy to get wrong with WSGI middleware being non compliant if not supported.  \n  \nNote that in this example the transformation being done does not modify the amount of data returned for the response. If the amount of data being returned is being modified then additional steps need to be taken to ensure a correct response. Options around what needs to be done where a WSGI middleware is changing the content length will be the subject of a future post.",
  "date": "Sunday, October 14, 2012",
  "author": "Graham Dumpleton",
  "url": "http://blog.dscpl.com.au/2012/10/wsgi-middleware-and-hidden-write.html",
  "post_id": "6369346180815684579",
  "blog_id": "2363643920942057324",
  "comments": [],
  "labels": [
    "python",
    "wsgi"
  ],
  "metadata": {
    "published_timestamp": "2012-10-14T23:17:00+11:00",
    "blog_title": "Graham Dumpleton",
    "page_title": "Graham Dumpleton: WSGI middleware and the hidden write() callable.",
    "og_title": "WSGI middleware and the hidden write() callable.",
    "og_description": "When I posted recently about the obligations of a WSGI server or middleware to call close()  on the iterable returned from a WSGI applicatio...",
    "og_url": "http://blog.dscpl.com.au/2012/10/wsgi-middleware-and-hidden-write.html"
  },
  "downloaded_images": []
}